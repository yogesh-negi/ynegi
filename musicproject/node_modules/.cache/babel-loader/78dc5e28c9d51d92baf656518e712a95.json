{"ast":null,"code":"/**\n * Module dependencies\n */\nvar util = require('util'); //var Writable  = require('stream').Writable;\n// This is a workaround to implement a _flush method for Writable (like for Transform) to emit the 'finish' event only after all data has been flushed to the underlying system (GridFS). See https://www.npmjs.com/package/flushwritable and https://github.com/joyent/node/issues/7348\n\n\nvar FlushWritable = require('flushwritable');\n/**\n * expose\n * @ignore\n */\n\n\nmodule.exports = exports = GridWriteStream;\n/**\n * GridWriteStream\n *\n * @param {Grid} grid\n * @param {Object} options (optional)\n */\n\nfunction GridWriteStream(grid, options) {\n  if (!(this instanceof GridWriteStream)) return new GridWriteStream(grid, options);\n  FlushWritable.call(this);\n  this._opened = false;\n  this._opening = false;\n  this._writable = true;\n  this._closing = false;\n  this._destroyed = false;\n  this._errorEmitted = false;\n  this._grid = grid; // a bit backwards compatible\n\n  if (typeof options === 'string') {\n    options = {\n      filename: options\n    };\n  }\n\n  this.options = options || {};\n\n  if (this.options._id) {\n    this.id = grid.tryParseObjectId(this.options._id);\n\n    if (!this.id) {\n      this.id = this.options._id;\n    }\n  }\n\n  this.name = this.options.filename; // This may be undefined, that's okay\n\n  if (!this.id) {\n    //_id not passed or unparsable? This is a new file!\n    this.id = new grid.mongo.ObjectID();\n    this.name = this.name || ''; // A new file needs a name\n  }\n\n  this.mode = 'w'; //Mongodb v2 driver have disabled w+ because of possible data corruption. So only allow `w` for now.\n  // The value of this.name may be undefined. GridStore treats that as a missing param\n  // in the call signature, which is what we want.\n\n  this._store = new grid.mongo.GridStore(grid.db, this.id, this.name, this.mode, this.options);\n  this._delayedWrite = null;\n  this._delayedFlush = null;\n  this._delayedClose = null;\n  var self = this;\n\n  self._open();\n}\n/**\n * Inherit from stream.Writable (FlushWritable for workaround to defer finish until all data flushed)\n * @ignore\n */\n\n\n_c = GridWriteStream;\nutil.inherits(GridWriteStream, FlushWritable); // private api\n\n/**\n * _open\n *\n * @api private\n */\n\nGridWriteStream.prototype._open = function () {\n  if (this._opened) return;\n  if (this._opening) return;\n  this._opening = true;\n  var self = this;\n\n  this._store.open(function (err, gs) {\n    self._opening = false;\n    if (err) return self._error(err);\n    self._opened = true;\n    self.emit('open'); // If _close was called during _store opening, then it was delayed until now, so do the close now\n\n    if (self._delayedClose) {\n      var closed = self._delayedClose.cb;\n      self._delayedClose = null;\n      return self._closeInternal(closed);\n    } // If _flush was called during _store opening, then it was delayed until now, so do the flush now (it's necessarily an empty GridFS file, no _write could have been called and have finished)\n\n\n    if (self._delayedFlush) {\n      var flushed = self._delayedFlush;\n      self._delayedFlush = null;\n      return self._flushInternal(flushed);\n    } // If _write was called during _store opening, then it was delayed until now, so do the write now (_flush could not have been called yet as _write has not finished yet)\n\n\n    if (self._delayedWrite) {\n      var delayedWrite = self._delayedWrite;\n      self._delayedWrite = null;\n      return self._writeInternal(delayedWrite.chunk, delayedWrite.encoding, delayedWrite.done);\n    }\n  });\n};\n/**\n * _writeInternal\n *\n * @api private\n */\n\n\nGridWriteStream.prototype._writeInternal = function (chunk, encoding, done) {\n  // If destroy or error no more data will be written.\n  if (!this._writable) return;\n  var self = this; // Write the chunk to the GridStore. The write head automatically moves along with each write.\n\n  this._store.write(chunk, function (err, store) {\n    if (err) return self._error(err); // Emit the write head position\n\n    self.emit('progress', store.position); // We are ready to receive a new chunk from the writestream - call done().\n\n    done();\n  });\n};\n/**\n * _write\n *\n * @api private\n */\n\n\nGridWriteStream.prototype._write = function (chunk, encoding, done) {\n  if (this._opening) {\n    // if we are still opening the store, then delay the write until it is open.\n    this._delayedWrite = {\n      chunk: chunk,\n      encoding: encoding,\n      done: done\n    };\n    return;\n  } // otherwise, do the write now\n\n\n  this._writeInternal(chunk, encoding, done);\n};\n/**\n * _flushInternal\n *\n * @api private\n */\n\n\nGridWriteStream.prototype._flushInternal = function (flushed) {\n  this._close(flushed);\n};\n/**\n * _flush\n *\n * @api private\n */\n\n\nGridWriteStream.prototype._flush = function (flushed) {\n  // _flush is called when all _write() have finished (even if no _write() was called (empty GridFS file))\n  if (this._opening) {\n    // if we are still opening the store, then delay the flush until it is open.\n    this._delayedFlush = flushed;\n    return;\n  } // otherwise, do the flush now\n\n\n  this._flushInternal(flushed);\n};\n/**\n * _closeInternal\n *\n * @api private\n */\n\n\nGridWriteStream.prototype._closeInternal = function (cb) {\n  if (!this._opened) return;\n  if (this._closing) return;\n  this._closing = true;\n  var self = this;\n\n  this._store.close(function (err, file) {\n    self._closing = false;\n    self._opened = false;\n    if (err) return self._error(err);\n    self.emit('close', file);\n    if (cb) cb();\n  });\n};\n/**\n * _close\n *\n * @api private\n */\n\n\nGridWriteStream.prototype._close = function _close(cb) {\n  if (this._opening) {\n    // if we are still opening the store, then delay the close until it is open.\n    this._delayedClose = {\n      cb: cb\n    };\n    return;\n  } // otherwise, do the close now\n\n\n  this._closeInternal(cb);\n};\n/**\n * _error\n *\n * @api private\n */\n\n\nGridWriteStream.prototype._error = function _error(err) {\n  // Stop receiving more data to write, emit `error` and close the store\n  if (this._errorEmitted) return;\n  this._errorEmitted = true;\n  this._writable = false;\n  this.emit('error', err);\n\n  this._close();\n}; // public api\n\n/**\n * destroy\n *\n * @api public\n */\n\n\nGridWriteStream.prototype.destroy = function destroy(err) {\n  // Abort the write stream, even if write not completed\n  if (this._destroyed) return;\n  this._destroyed = true;\n  var self = this;\n  process.nextTick(function () {\n    self._error(err);\n  });\n};\n/**\n * destroySoon\n *\n * @api public\n * @deprecated just use destroy()\n */\n\n\nGridWriteStream.prototype.destroySoon = function destroySoon() {\n  return this.destroy();\n};\n\nvar _c;\n\n$RefreshReg$(_c, \"GridWriteStream\");","map":{"version":3,"sources":["C:/Users/Yogesh/Desktop/musicplayer/musicapp/musicproject/src/api/node_modules/gridfs-stream/lib/writestream.js"],"names":["util","require","FlushWritable","module","exports","GridWriteStream","grid","options","call","_opened","_opening","_writable","_closing","_destroyed","_errorEmitted","_grid","filename","_id","id","tryParseObjectId","name","mongo","ObjectID","mode","_store","GridStore","db","_delayedWrite","_delayedFlush","_delayedClose","self","_open","inherits","prototype","open","err","gs","_error","emit","closed","cb","_closeInternal","flushed","_flushInternal","delayedWrite","_writeInternal","chunk","encoding","done","write","store","position","_write","_close","_flush","close","file","destroy","process","nextTick","destroySoon"],"mappings":"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","sourcesContent":["\n/**\n * Module dependencies\n */\n\nvar util = require('util');\n//var Writable  = require('stream').Writable;\n\n// This is a workaround to implement a _flush method for Writable (like for Transform) to emit the 'finish' event only after all data has been flushed to the underlying system (GridFS). See https://www.npmjs.com/package/flushwritable and https://github.com/joyent/node/issues/7348\nvar FlushWritable = require('flushwritable');\n\n/**\n * expose\n * @ignore\n */\n\nmodule.exports = exports = GridWriteStream;\n\n/**\n * GridWriteStream\n *\n * @param {Grid} grid\n * @param {Object} options (optional)\n */\n\nfunction GridWriteStream (grid, options) {\n\tif (!(this instanceof GridWriteStream))\n\t\treturn new GridWriteStream(grid, options);\n\n\tFlushWritable.call(this);\n\tthis._opened = false;\n\tthis._opening = false;\n\tthis._writable = true;\n\tthis._closing = false;\n\tthis._destroyed = false;\n\tthis._errorEmitted = false;\n\tthis._grid = grid;\n\n\t// a bit backwards compatible\n\tif (typeof options === 'string') {\n\t\toptions = { filename: options };\n\t}\n\tthis.options = options || {};\n\tif(this.options._id) {\n\t\tthis.id = grid.tryParseObjectId(this.options._id);\n\n\t\tif(!this.id) {\n\t\t\tthis.id = this.options._id;\n\t\t}\n\t}\n\n\tthis.name = this.options.filename;  // This may be undefined, that's okay\n\n\tif (!this.id) {\n\t\t//_id not passed or unparsable? This is a new file!\n\t\tthis.id = new grid.mongo.ObjectID();\n\t\tthis.name = this.name || '';  // A new file needs a name\n\t}\n\n\tthis.mode = 'w'; //Mongodb v2 driver have disabled w+ because of possible data corruption. So only allow `w` for now.\n\n\t// The value of this.name may be undefined. GridStore treats that as a missing param\n\t// in the call signature, which is what we want.\n\tthis._store = new grid.mongo.GridStore(grid.db, this.id, this.name, this.mode, this.options);\n\n\tthis._delayedWrite = null;\n\tthis._delayedFlush = null;\n\tthis._delayedClose = null;\n\n\tvar self = this;\n\n\tself._open();\n}\n\n/**\n * Inherit from stream.Writable (FlushWritable for workaround to defer finish until all data flushed)\n * @ignore\n */\n\nutil.inherits(GridWriteStream, FlushWritable);\n\n// private api\n\n/**\n * _open\n *\n * @api private\n */\n\nGridWriteStream.prototype._open = function () {\n\tif (this._opened) return;\n\tif (this._opening) return;\n\tthis._opening = true;\n\n\tvar self = this;\n\tthis._store.open(function (err, gs) {\n\t\tself._opening = false;\n\t\tif (err) return self._error(err);\n\t\tself._opened = true;\n\t\tself.emit('open');\n\n\t\t// If _close was called during _store opening, then it was delayed until now, so do the close now\n\t\tif (self._delayedClose) {\n\t\t\tvar closed = self._delayedClose.cb;\n\t\t\tself._delayedClose = null;\n\t\t\treturn self._closeInternal(closed);\n\t\t}\n\n\t\t// If _flush was called during _store opening, then it was delayed until now, so do the flush now (it's necessarily an empty GridFS file, no _write could have been called and have finished)\n\t\tif (self._delayedFlush) {\n\t\t\tvar flushed = self._delayedFlush;\n\t\t\tself._delayedFlush = null;\n\t\t\treturn self._flushInternal(flushed);\n\t\t}\n\n\t\t// If _write was called during _store opening, then it was delayed until now, so do the write now (_flush could not have been called yet as _write has not finished yet)\n\t\tif (self._delayedWrite) {\n\t\t\tvar delayedWrite = self._delayedWrite;\n\t\t\tself._delayedWrite = null;\n\t\t\treturn self._writeInternal(delayedWrite.chunk, delayedWrite.encoding, delayedWrite.done);\n\t\t}\n\t});\n}\n\n/**\n * _writeInternal\n *\n * @api private\n */\n\nGridWriteStream.prototype._writeInternal = function (chunk, encoding, done) {\n\t// If destroy or error no more data will be written.\n\tif (!this._writable) return;\n\n\tvar self = this;\n\t// Write the chunk to the GridStore. The write head automatically moves along with each write.\n\tthis._store.write(chunk, function (err, store) {\n\t\tif (err) return self._error(err);\n\n\t\t// Emit the write head position\n\t\tself.emit('progress', store.position);\n\n\t\t// We are ready to receive a new chunk from the writestream - call done().\n\t\tdone();\n\t});\n}\n\n/**\n * _write\n *\n * @api private\n */\n\nGridWriteStream.prototype._write = function (chunk, encoding, done) {\n\tif (this._opening) {\n\t\t// if we are still opening the store, then delay the write until it is open.\n\t\tthis._delayedWrite = {chunk: chunk, encoding: encoding, done: done};\n\t\treturn;\n\t}\n\n\t// otherwise, do the write now\n\tthis._writeInternal(chunk, encoding, done);\n}\n\n/**\n * _flushInternal\n *\n * @api private\n */\n\nGridWriteStream.prototype._flushInternal = function (flushed) {\n\tthis._close(flushed);\n}\n\n/**\n * _flush\n *\n * @api private\n */\n\nGridWriteStream.prototype._flush = function (flushed) {\n\t// _flush is called when all _write() have finished (even if no _write() was called (empty GridFS file))\n\n\tif (this._opening) {\n\t\t// if we are still opening the store, then delay the flush until it is open.\n\t\tthis._delayedFlush = flushed;\n\t\treturn;\n\t}\n\n\t// otherwise, do the flush now\n\tthis._flushInternal(flushed);\n}\n\n\n/**\n * _closeInternal\n *\n * @api private\n */\n\nGridWriteStream.prototype._closeInternal = function (cb) {\n\tif (!this._opened) return;\n\tif (this._closing) return;\n\tthis._closing = true;\n\n\tvar self = this;\n\tthis._store.close(function (err, file) {\n\t\tself._closing = false;\n\t\tself._opened = false;\n\t\tif (err) return self._error(err);\n\t\tself.emit('close', file);\n\n\t\tif (cb) cb();\n\t});\n}\n\n/**\n * _close\n *\n * @api private\n */\n\nGridWriteStream.prototype._close = function _close (cb) {\n\tif (this._opening) {\n\t\t// if we are still opening the store, then delay the close until it is open.\n\t\tthis._delayedClose = { cb: cb };\n\t\treturn;\n\t}\n\n\t// otherwise, do the close now\n\tthis._closeInternal(cb);\n}\n\n/**\n * _error\n *\n * @api private\n */\n\nGridWriteStream.prototype._error = function _error (err) {\n\t// Stop receiving more data to write, emit `error` and close the store\n\tif (this._errorEmitted) return;\n\tthis._errorEmitted = true;\n\n\tthis._writable = false;\n\tthis.emit('error', err);\n\tthis._close();\n}\n\n// public api\n\n/**\n * destroy\n *\n * @api public\n */\n\nGridWriteStream.prototype.destroy = function destroy (err) {\n\t// Abort the write stream, even if write not completed\n\tif (this._destroyed) return;\n\tthis._destroyed = true;\n\n\tvar self = this;\n\tprocess.nextTick(function() {\n\t\tself._error(err);\n\t});\n}\n\n\n/**\n * destroySoon\n *\n * @api public\n * @deprecated just use destroy()\n */\n\nGridWriteStream.prototype.destroySoon = function destroySoon () {\n\treturn this.destroy();\n};"]},"metadata":{},"sourceType":"module"}