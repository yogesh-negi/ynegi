{"ast":null,"code":"/**\n * Storage cache\n * @module multer-gridfs-storage/cache\n */\nconst {\n  EventEmitter\n} = require('events');\n\nconst mongoUri = require('mongodb-uri');\n\nconst hasOwn = require('has-own-prop');\n\nconst {\n  compare,\n  compareUris\n} = require('./utils');\n/**\n * Plugin cached connection handling class.\n * @version 3.1.0\n */\n\n\nclass Cache {\n  constructor() {\n    this._connections = {};\n    this._emitter = new EventEmitter();\n\n    this._emitter.setMaxListeners(0);\n  }\n  /**\n   * Handles creating a new connection from an url and caching if necessary\n   * @param {object} options - Options to initialize the cache\n   * @param {string} options.url - The url to cache\n   * @param {string} options.cacheName - The name of the cache to use\n   * @param {any} options.init - The connection options provided\n   **/\n\n\n  initialize(options) {\n    let {\n      url,\n      cacheName: name\n    } = options; // If the option is a falsey value or empty object use null as initial value\n\n    const init = compare(options.init, null) ? null : options.init; // If a cache under that name does not exist create one\n\n    if (!this._connections[name]) {\n      this._connections[name] = {};\n    } // Check if the url has been used for that cache before\n\n\n    let cached = this._connections[name][url];\n\n    if (!cached) {\n      // If the url matches any equivalent url used before use that connection instead\n      const eqUrl = this.findUri(name, url);\n\n      if (!eqUrl) {\n        this._connections[name][url] = {\n          connections: 1,\n          next: 1\n        };\n        this._connections[name][url]['0'] = {\n          db: null,\n          client: null,\n          pending: true,\n          opening: false,\n          init\n        };\n        return {\n          url,\n          name,\n          index: '0'\n        };\n      }\n\n      url = eqUrl;\n      cached = this._connections[name][url];\n    } // Compare connection options to create more only if they are semantically different\n\n\n    for (const prop in cached) {\n      if (hasOwn(cached, prop)) {\n        const current = cached[prop];\n\n        if (compare(current.init, options.init)) {\n          return {\n            url,\n            name,\n            index: prop\n          };\n        }\n      }\n    } // Allocate a new cache incrementing the autogenerated index for that space\n\n\n    const index = cached.next.toString();\n    cached[index] = {\n      db: null,\n      client: null,\n      pending: true,\n      opening: false,\n      init\n    };\n    cached.connections++;\n    cached.next++;\n    return {\n      url,\n      name,\n      index\n    };\n  }\n  /**\n   * Search the cache for a space stored under an equivalent url.\n   *\n   * Just swapping parameters can cause two url to be deemed different when in fact they are not.\n   * This method finds an url in the cache where another url could be stored even when they are not strictly equal\n   * @param cacheName The name of the cache to search\n   * @param url The mongodb url to compare\n   * @return {string} The similar url already in the cache\n   */\n\n\n  findUri(cacheName, url) {\n    const cache = this._connections[cacheName];\n\n    for (const prop in cache) {\n      if (hasOwn(cache, prop)) {\n        const parsedUri = mongoUri.parse(prop);\n        const parsedCache = mongoUri.parse(url);\n\n        if (compareUris(parsedUri, parsedCache)) {\n          return prop;\n        }\n      }\n    }\n  }\n  /**\n   * Returns true if the cache has an entry matching the given index\n   * @param cacheIndex {object} The index to look for\n   * @return {boolean} Returns if the cache was found\n   */\n\n\n  has(cacheIndex) {\n    return Boolean(this.get(cacheIndex));\n  }\n  /**\n   * Returns the contents of the cache in a given index\n   * @param cacheIndex {object} The index to look for\n   * @return {object} The cache contents or null if was not found\n   */\n\n\n  get(cacheIndex) {\n    const {\n      name\n    } = cacheIndex;\n    const {\n      url\n    } = cacheIndex;\n    const {\n      index\n    } = cacheIndex;\n\n    if (!this._connections[name]) {\n      return null;\n    }\n\n    if (!this._connections[name][url]) {\n      return null;\n    }\n\n    if (!this._connections[name][url][index]) {\n      return null;\n    }\n\n    return this._connections[name][url][index];\n  }\n  /**\n   * Sets the contents of the cache in a given index\n   * @param cacheIndex {object} The index to look for\n   * @param value {object} The value to set\n   */\n\n\n  set(cacheIndex, value) {\n    this._connections[cacheIndex.name][cacheIndex.url][cacheIndex.index] = value;\n  }\n  /**\n   * Returns true if a given cache is resolving its associated connection\n   * @param cacheIndex {object} The index to look for\n   * @return {boolean} Return true if the connection is not found yet\n   */\n\n\n  isPending(cacheIndex) {\n    const cached = this.get(cacheIndex);\n    return Boolean(cached) && cached.pending;\n  }\n  /**\n   * Return true if a given cache started resolving a connection for itself\n   * @param cacheIndex {object} The index to look for\n   * @return {boolean} Return true if no instances have started creating a connection for this cache\n   */\n\n\n  isOpening(cacheIndex) {\n    const cached = this.get(cacheIndex);\n    return cached && cached.opening;\n  }\n  /**\n   * Sets the database and client for a given cache and resolves all instances waiting for it\n   * @param cacheIndex {object} The index to look for\n   * @param db {Db} The database used to store files\n   * @param client {MongoClient} The client used to open the connection or null if none is provided\n   */\n\n\n  resolve(cacheIndex, db, client) {\n    const cached = this.get(cacheIndex);\n    cached.db = db;\n    cached.client = client;\n    cached.pending = false;\n    cached.opening = false;\n\n    this._emitter.emit('resolve', cacheIndex);\n  }\n  /**\n   * Rejects all instances waiting for this connections\n   * @param cacheIndex {object} The index to look for\n   * @param err {Error} The error thrown by the driver\n   */\n\n\n  reject(cacheIndex, err) {\n    const cached = this.get(cacheIndex);\n    cached.pending = false;\n\n    this._emitter.emit('reject', cacheIndex, err);\n\n    this.remove(cacheIndex);\n  }\n  /**\n   * Allows waiting for a connection associated to a given cache\n   * @param cacheIndex {any} The index to look for\n   * @return {Promise} A promise that will resolve when the connection for this cache is created\n   */\n\n\n  async waitFor(cacheIndex) {\n    if (!this.isPending(cacheIndex) && !this.isOpening(cacheIndex)) {\n      return this.get(cacheIndex);\n    }\n\n    return new Promise((resolve, reject) => {\n      const _resolve = index => {\n        if (compare(cacheIndex, index)) {\n          this._emitter.removeListener('resolve', _resolve);\n\n          this._emitter.removeListener('reject', _reject);\n\n          resolve(this.get(cacheIndex));\n        }\n      };\n\n      const _reject = (index, err) => {\n        if (compare(cacheIndex, index)) {\n          this._emitter.removeListener('resolve', _resolve);\n\n          this._emitter.removeListener('reject', _reject);\n\n          reject(err);\n        }\n      };\n\n      this._emitter.on('resolve', _resolve);\n\n      this._emitter.on('reject', _reject);\n    });\n  }\n  /**\n   * Gives the number of connections created by all cache instances\n   * @return {number} The number of created connections\n   */\n\n\n  connections() {\n    let total = 0;\n\n    for (const con in this._connections) {\n      if (hasOwn(this._connections, con)) {\n        const current = this._connections[con];\n\n        for (const url in current) {\n          if (hasOwn(current, url)) {\n            total += current[url].connections;\n          }\n        }\n      }\n    }\n\n    return total;\n  }\n  /**\n   * Removes a cache entry.\n   *\n   * > If the cache hasn't resolved yet it will be rejected.\n   * @param cacheIndex {object} The index to look for\n   */\n\n\n  remove(cacheIndex) {\n    const {\n      name\n    } = cacheIndex;\n    const {\n      url\n    } = cacheIndex;\n    const {\n      index\n    } = cacheIndex;\n\n    if (this._connections[name] && this._connections[name][url] && this._connections[name][url][index]) {\n      if (this.isPending(cacheIndex)) {\n        this._emitter.emit('reject', cacheIndex, new Error('The cache entry was deleted'));\n      }\n\n      delete this._connections[name][url][index];\n      this._connections[name][url].connections--;\n    }\n  }\n  /**\n   * Removes all entries in the cache and all listeners\n   */\n\n\n  clear() {\n    this._connections = {};\n\n    this._emitter.removeAllListeners();\n  }\n\n}\n\nmodule.exports = Cache;","map":{"version":3,"sources":["C:/Users/Yogesh/Desktop/musicplayer/musicapp/musicproject/src/api/node_modules/multer-gridfs-storage/lib/cache.js"],"names":["EventEmitter","require","mongoUri","hasOwn","compare","compareUris","Cache","constructor","_connections","_emitter","setMaxListeners","initialize","options","url","cacheName","name","init","cached","eqUrl","findUri","connections","next","db","client","pending","opening","index","prop","current","toString","cache","parsedUri","parse","parsedCache","has","cacheIndex","Boolean","get","set","value","isPending","isOpening","resolve","emit","reject","err","remove","waitFor","Promise","_resolve","removeListener","_reject","on","total","con","Error","clear","removeAllListeners","module","exports"],"mappings":"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","sourcesContent":["/**\n * Storage cache\n * @module multer-gridfs-storage/cache\n */\nconst {EventEmitter} = require('events');\nconst mongoUri = require('mongodb-uri');\nconst hasOwn = require('has-own-prop');\nconst {compare, compareUris} = require('./utils');\n\n/**\n * Plugin cached connection handling class.\n * @version 3.1.0\n */\nclass Cache {\n\tconstructor() {\n\t\tthis._connections = {};\n\t\tthis._emitter = new EventEmitter();\n\t\tthis._emitter.setMaxListeners(0);\n\t}\n\n\t/**\n\t * Handles creating a new connection from an url and caching if necessary\n\t * @param {object} options - Options to initialize the cache\n\t * @param {string} options.url - The url to cache\n\t * @param {string} options.cacheName - The name of the cache to use\n\t * @param {any} options.init - The connection options provided\n\t **/\n\tinitialize(options) {\n\t\tlet {url, cacheName: name} = options;\n\t\t// If the option is a falsey value or empty object use null as initial value\n\t\tconst init = compare(options.init, null) ? null : options.init;\n\n\t\t// If a cache under that name does not exist create one\n\t\tif (!this._connections[name]) {\n\t\t\tthis._connections[name] = {};\n\t\t}\n\n\t\t// Check if the url has been used for that cache before\n\t\tlet cached = this._connections[name][url];\n\t\tif (!cached) {\n\t\t\t// If the url matches any equivalent url used before use that connection instead\n\t\t\tconst eqUrl = this.findUri(name, url);\n\t\t\tif (!eqUrl) {\n\t\t\t\tthis._connections[name][url] = {connections: 1, next: 1};\n\t\t\t\tthis._connections[name][url]['0'] = {\n\t\t\t\t\tdb: null,\n\t\t\t\t\tclient: null,\n\t\t\t\t\tpending: true,\n\t\t\t\t\topening: false,\n\t\t\t\t\tinit\n\t\t\t\t};\n\n\t\t\t\treturn {\n\t\t\t\t\turl,\n\t\t\t\t\tname,\n\t\t\t\t\tindex: '0'\n\t\t\t\t};\n\t\t\t}\n\n\t\t\turl = eqUrl;\n\t\t\tcached = this._connections[name][url];\n\t\t}\n\n\t\t// Compare connection options to create more only if they are semantically different\n\t\tfor (const prop in cached) {\n\t\t\tif (hasOwn(cached, prop)) {\n\t\t\t\tconst current = cached[prop];\n\t\t\t\tif (compare(current.init, options.init)) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\turl,\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tindex: prop\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Allocate a new cache incrementing the autogenerated index for that space\n\t\tconst index = cached.next.toString();\n\t\tcached[index] = {\n\t\t\tdb: null,\n\t\t\tclient: null,\n\t\t\tpending: true,\n\t\t\topening: false,\n\t\t\tinit\n\t\t};\n\t\tcached.connections++;\n\t\tcached.next++;\n\n\t\treturn {\n\t\t\turl,\n\t\t\tname,\n\t\t\tindex\n\t\t};\n\t}\n\n\t/**\n\t * Search the cache for a space stored under an equivalent url.\n\t *\n\t * Just swapping parameters can cause two url to be deemed different when in fact they are not.\n\t * This method finds an url in the cache where another url could be stored even when they are not strictly equal\n\t * @param cacheName The name of the cache to search\n\t * @param url The mongodb url to compare\n\t * @return {string} The similar url already in the cache\n\t */\n\tfindUri(cacheName, url) {\n\t\tconst cache = this._connections[cacheName];\n\t\tfor (const prop in cache) {\n\t\t\tif (hasOwn(cache, prop)) {\n\t\t\t\tconst parsedUri = mongoUri.parse(prop);\n\t\t\t\tconst parsedCache = mongoUri.parse(url);\n\t\t\t\tif (compareUris(parsedUri, parsedCache)) {\n\t\t\t\t\treturn prop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns true if the cache has an entry matching the given index\n\t * @param cacheIndex {object} The index to look for\n\t * @return {boolean} Returns if the cache was found\n\t */\n\thas(cacheIndex) {\n\t\treturn Boolean(this.get(cacheIndex));\n\t}\n\n\t/**\n\t * Returns the contents of the cache in a given index\n\t * @param cacheIndex {object} The index to look for\n\t * @return {object} The cache contents or null if was not found\n\t */\n\tget(cacheIndex) {\n\t\tconst {name} = cacheIndex;\n\t\tconst {url} = cacheIndex;\n\t\tconst {index} = cacheIndex;\n\t\tif (!this._connections[name]) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!this._connections[name][url]) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!this._connections[name][url][index]) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this._connections[name][url][index];\n\t}\n\n\t/**\n\t * Sets the contents of the cache in a given index\n\t * @param cacheIndex {object} The index to look for\n\t * @param value {object} The value to set\n\t */\n\tset(cacheIndex, value) {\n\t\tthis._connections[cacheIndex.name][cacheIndex.url][\n\t\t\tcacheIndex.index\n\t\t] = value;\n\t}\n\n\t/**\n\t * Returns true if a given cache is resolving its associated connection\n\t * @param cacheIndex {object} The index to look for\n\t * @return {boolean} Return true if the connection is not found yet\n\t */\n\tisPending(cacheIndex) {\n\t\tconst cached = this.get(cacheIndex);\n\t\treturn Boolean(cached) && cached.pending;\n\t}\n\n\t/**\n\t * Return true if a given cache started resolving a connection for itself\n\t * @param cacheIndex {object} The index to look for\n\t * @return {boolean} Return true if no instances have started creating a connection for this cache\n\t */\n\tisOpening(cacheIndex) {\n\t\tconst cached = this.get(cacheIndex);\n\t\treturn cached && cached.opening;\n\t}\n\n\t/**\n\t * Sets the database and client for a given cache and resolves all instances waiting for it\n\t * @param cacheIndex {object} The index to look for\n\t * @param db {Db} The database used to store files\n\t * @param client {MongoClient} The client used to open the connection or null if none is provided\n\t */\n\tresolve(cacheIndex, db, client) {\n\t\tconst cached = this.get(cacheIndex);\n\t\tcached.db = db;\n\t\tcached.client = client;\n\t\tcached.pending = false;\n\t\tcached.opening = false;\n\t\tthis._emitter.emit('resolve', cacheIndex);\n\t}\n\n\t/**\n\t * Rejects all instances waiting for this connections\n\t * @param cacheIndex {object} The index to look for\n\t * @param err {Error} The error thrown by the driver\n\t */\n\treject(cacheIndex, err) {\n\t\tconst cached = this.get(cacheIndex);\n\t\tcached.pending = false;\n\t\tthis._emitter.emit('reject', cacheIndex, err);\n\t\tthis.remove(cacheIndex);\n\t}\n\n\t/**\n\t * Allows waiting for a connection associated to a given cache\n\t * @param cacheIndex {any} The index to look for\n\t * @return {Promise} A promise that will resolve when the connection for this cache is created\n\t */\n\tasync waitFor(cacheIndex) {\n\t\tif (!this.isPending(cacheIndex) && !this.isOpening(cacheIndex)) {\n\t\t\treturn this.get(cacheIndex);\n\t\t}\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst _resolve = (index) => {\n\t\t\t\tif (compare(cacheIndex, index)) {\n\t\t\t\t\tthis._emitter.removeListener('resolve', _resolve);\n\t\t\t\t\tthis._emitter.removeListener('reject', _reject);\n\t\t\t\t\tresolve(this.get(cacheIndex));\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst _reject = (index, err) => {\n\t\t\t\tif (compare(cacheIndex, index)) {\n\t\t\t\t\tthis._emitter.removeListener('resolve', _resolve);\n\t\t\t\t\tthis._emitter.removeListener('reject', _reject);\n\t\t\t\t\treject(err);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis._emitter.on('resolve', _resolve);\n\t\t\tthis._emitter.on('reject', _reject);\n\t\t});\n\t}\n\n\t/**\n\t * Gives the number of connections created by all cache instances\n\t * @return {number} The number of created connections\n\t */\n\tconnections() {\n\t\tlet total = 0;\n\t\tfor (const con in this._connections) {\n\t\t\tif (hasOwn(this._connections, con)) {\n\t\t\t\tconst current = this._connections[con];\n\t\t\t\tfor (const url in current) {\n\t\t\t\t\tif (hasOwn(current, url)) {\n\t\t\t\t\t\ttotal += current[url].connections;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn total;\n\t}\n\n\t/**\n\t * Removes a cache entry.\n\t *\n\t * > If the cache hasn't resolved yet it will be rejected.\n\t * @param cacheIndex {object} The index to look for\n\t */\n\tremove(cacheIndex) {\n\t\tconst {name} = cacheIndex;\n\t\tconst {url} = cacheIndex;\n\t\tconst {index} = cacheIndex;\n\n\t\tif (\n\t\t\tthis._connections[name] &&\n\t\t\tthis._connections[name][url] &&\n\t\t\tthis._connections[name][url][index]\n\t\t) {\n\t\t\tif (this.isPending(cacheIndex)) {\n\t\t\t\tthis._emitter.emit(\n\t\t\t\t\t'reject',\n\t\t\t\t\tcacheIndex,\n\t\t\t\t\tnew Error('The cache entry was deleted')\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tdelete this._connections[name][url][index];\n\t\t\tthis._connections[name][url].connections--;\n\t\t}\n\t}\n\n\t/**\n\t * Removes all entries in the cache and all listeners\n\t */\n\tclear() {\n\t\tthis._connections = {};\n\t\tthis._emitter.removeAllListeners();\n\t}\n}\n\nmodule.exports = Cache;\n"]},"metadata":{},"sourceType":"module"}