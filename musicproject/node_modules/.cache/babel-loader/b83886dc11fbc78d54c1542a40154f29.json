{"ast":null,"code":"/**\n *\n * Plugin definition\n * @module multer-gridfs-storage/gridfs\n *\n */\nconst crypto = require('crypto');\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst mongodb = require('mongodb');\n\nconst isPromise = require('is-promise');\n\nconst isGenerator = require('is-generator');\n\nconst isGeneratorFn = isGenerator.fn;\n\nconst pump = require('pump');\n\nconst mongoUri = require('mongodb-uri');\n\nconst {\n  getDatabase\n} = require('./utils');\n\nconst Cache = require('./cache');\n\nconst {\n  ObjectID,\n  MongoClient\n} = mongodb;\n/**\n * Is GridFSBucket present or not\n * @const legacy\n **/\n\nconst legacy = !mongodb.GridFSBucket;\n/**\n * Default file information\n * @const defaults\n **/\n\nconst defaults = {\n  metadata: null,\n  chunkSize: 261120,\n  bucketName: 'fs',\n  aliases: null\n};\n/**\n * Multer GridFS Storage Engine class definition.\n * @extends EventEmitter\n * @param {object} configuration\n * @param {string} [configuration.url] - The url pointing to a MongoDb database\n * @param {object} [configuration.options] - Options to use when connection with an url.\n * @param {object} [configuration.connectionOpts] - DEPRECATED: Use options instead.\n * @param {boolean | string} [configuration.cache] - Store this connection in the internal cache.\n * @param {Db | Promise} [configuration.db] - The MongoDb database instance to use or a promise that resolves with it\n * @param {Function} [configuration.file] - A function to control the file naming in the database\n * @fires GridFSStorage#connection\n * @fires GridFSStorage#connectionFailed\n * @fires GridFSStorage#file\n * @fires GridFSStorage#streamError\n * @fires GridFSStorage#dbError\n * @version 0.0.3\n */\n\nclass GridFSStorage extends EventEmitter {\n  constructor(configuration) {\n    super();\n\n    if (!configuration || !configuration.url && !configuration.db) {\n      throw new Error('Error creating storage engine. At least one of url or db option must be provided.');\n    }\n\n    this.setMaxListeners(0);\n    this.db = null;\n    this.client = null;\n    this.connected = false;\n    this.connecting = false;\n    this.configuration = configuration;\n    this.caching = false;\n    this.cacheName = null;\n    this.cacheIndex = null;\n    this.error = null;\n    this._file = this.configuration.file;\n    this._legacy = legacy;\n\n    if (this.configuration.url) {\n      this.caching = Boolean(this.configuration.cache);\n      this._options = this.configuration.options;\n    }\n\n    if (this.caching) {\n      this.cacheName = typeof configuration.cache === 'string' ? configuration.cache : 'default';\n      this.cacheIndex = GridFSStorage.cache.initialize({\n        url: configuration.url,\n        cacheName: this.cacheName,\n        init: this._options\n      });\n    }\n\n    this._connect();\n  }\n  /**\n   * Determines if a new connection should be created, a explicit connection is provided or a cached instance is required.\n   * @private\n   */\n\n\n  _connect() {\n    const {\n      db,\n      client = null\n    } = this.configuration;\n\n    if (db && !isPromise(db) && !isPromise(client)) {\n      this._setDb(db, client);\n\n      return;\n    }\n\n    this._resolveConnection()\n    /* eslint-disable-next-line promise/prefer-await-to-then */\n    .then(({\n      db,\n      client\n    }) => {\n      this._setDb(db, client);\n    }).catch(error => this._fail(error));\n  }\n  /**\n   * Returns a promise that will resolve to the db and client from the cache or a new connection depending on the provided configuration\n   * @return {Promise<{client: *, db: *}>}\n   * @private\n   */\n\n\n  async _resolveConnection() {\n    this.connecting = true;\n    const {\n      db,\n      client = null\n    } = this.configuration;\n\n    if (db) {\n      const [_db, _client] = await Promise.all([db, client]);\n      return {\n        db: _db,\n        client: _client\n      };\n    }\n\n    if (!this.caching) {\n      return this._createConnection();\n    }\n\n    const {\n      cache\n    } = GridFSStorage;\n\n    if (!cache.isOpening(this.cacheIndex) && cache.isPending(this.cacheIndex)) {\n      const cached = cache.get(this.cacheIndex);\n      cached.opening = true;\n      return this._createConnection();\n    }\n\n    return cache.waitFor(this.cacheIndex);\n  }\n  /**\n   * Handles creating a new connection from an url and storing it in the cache if necessary\n   * @return {Promise<{client: *, db: *}>}\n   * @private\n   */\n\n\n  async _createConnection() {\n    const {\n      url\n    } = this.configuration;\n    const {\n      _options: options\n    } = this;\n    const {\n      cache\n    } = GridFSStorage;\n\n    try {\n      let db;\n      let client = null;\n\n      const _db = await MongoClient.connect(url, options);\n\n      let parsedUri; // Mongo 3 returns a client instead of a Db object\n\n      if (_db instanceof MongoClient) {\n        client = _db;\n        parsedUri = mongoUri.parse(url);\n        db = client.db(parsedUri.database);\n      } else {\n        db = _db;\n      }\n\n      if (this.caching) {\n        cache.resolve(this.cacheIndex, db, client);\n      }\n\n      return {\n        db,\n        client\n      };\n    } catch (error) {\n      if (this.cacheIndex) {\n        cache.reject(this.cacheIndex, error);\n      }\n\n      throw error;\n    }\n  }\n  /**\n   * Updates the connection status based on the internal db or client object\n   * @private\n   **/\n\n\n  _updateConnectionStatus() {\n    if (!this.db) {\n      this.connected = false;\n      this.connecting = false;\n      return;\n    }\n\n    if (this.client) {\n      this.connected = this.client.isConnected ? this.client.isConnected() : true;\n      return;\n    }\n\n    this.connected = this.db.topology.isConnected();\n  }\n  /**\n   * Sets the database connection and emit the connection event\n   * @param {object} db - Database instance or Mongoose instance to set\n   * @param {object} [client] - Optional Mongo client for MongoDb v3\n   * @private\n   **/\n\n\n  _setDb(db, client) {\n    this.connecting = false; // Check if the object is a mongoose instance, a mongoose Connection or a mongo Db object\n\n    this.db = getDatabase(db);\n\n    if (client) {\n      this.client = client;\n    }\n\n    const errEvent = err => {\n      // Needs verification. Sometimes the event fires without an error object\n      // although the docs specify each of the events has a MongoError argument\n      this._updateConnectionStatus();\n\n      const error = err || new Error();\n      this.emit('dbError', error);\n    }; // This are all the events that emit errors\n\n\n    this.db.on('error', errEvent).on('parseError', errEvent).on('timeout', errEvent).on('close', errEvent);\n\n    this._updateConnectionStatus(); // Emit on next tick so user code can set listeners in case the db object is already available\n\n\n    process.nextTick(() => {\n      this.emit('connection', {\n        db: this.db,\n        client: this.client\n      });\n    });\n  }\n  /**\n   * Removes the database reference and emit the connectionFailed event\n   * @param {object} err - The error received while trying to connect\n   * @private\n   **/\n\n\n  _fail(err) {\n    this.connecting = false;\n    this.db = null;\n    this.client = null;\n    this.error = err;\n\n    this._updateConnectionStatus(); // Fail event is only emitted after either a then promise handler or an I/O phase so is guaranteed to be asynchronous\n\n\n    this.emit('connectionFailed', err);\n  }\n  /**\n   * Create a writable stream with backwards compatibility with GridStore\n   * @param {object} options - The stream options\n   * @return {GridStoreStream | GridFSBucketWriteStream}\n   */\n\n\n  createStream(options) {\n    let gfs;\n    let settings;\n    const {\n      GridStore\n    } = mongodb;\n    const {\n      GridFSBucket\n    } = mongodb;\n\n    if (this._legacy) {\n      // `disableMD5` is not supported in GridStore\n      settings = {\n        /* eslint-disable-next-line camelcase */\n        chunk_size: options.chunkSize,\n        metadata: options.metadata,\n\n        /* eslint-disable-next-line camelcase */\n        content_type: options.contentType,\n        root: options.bucketName,\n        aliases: options.aliases\n      };\n      gfs = new GridStore(this.db, options.id, options.filename, 'w', settings);\n      return gfs.stream();\n    }\n\n    settings = {\n      id: options.id,\n      chunkSizeBytes: options.chunkSize,\n      contentType: options.contentType,\n      metadata: options.metadata,\n      aliases: options.aliases,\n      disableMD5: options.disableMD5\n    };\n    gfs = new GridFSBucket(this.db, {\n      bucketName: options.bucketName\n    });\n    return gfs.openUploadStream(options.filename, settings);\n  }\n  /**\n   * Storage interface method to handle incoming files\n   * @param {Request} request - The request that trigger the upload\n   * @param {File} file - The uploaded file stream\n   * @param {function} cb - A standard node callback to signal the end of the upload or an error\n   **/\n\n\n  _handleFile(request, file, cb) {\n    if (this.connecting) {\n      this.ready()\n      /* eslint-disable-next-line promise/prefer-await-to-then */\n      .then(() => this.fromFile(request, file))\n      /* eslint-disable-next-line promise/prefer-await-to-then */\n      .then(file => cb(null, file)).catch(cb);\n      return;\n    }\n\n    this._updateConnectionStatus();\n\n    if (this.connected) {\n      this.fromFile(request, file)\n      /* eslint-disable-next-line promise/prefer-await-to-then */\n      .then(file => cb(null, file)).catch(cb);\n      return;\n    }\n\n    cb(new Error('The database connection must be open to store files'));\n  }\n  /**\n   * Storage interface method to delete files in case an error turns the request invalid\n   * @param {Request} request - The request that trigger the upload\n   * @param {File} file - The uploaded file stream\n   * @param {function} cb - A standard node callback to signal the end of the upload or an error\n   **/\n\n\n  _removeFile(request, file, cb) {\n    let bucket;\n    let options;\n    const {\n      GridStore\n    } = mongodb;\n    const {\n      GridFSBucket\n    } = mongodb;\n\n    if (this._legacy) {\n      options = {\n        root: file.bucketName\n      };\n      GridStore.unlink(this.db, file.id, options, cb);\n    } else {\n      options = {\n        bucketName: file.bucketName\n      };\n      bucket = new GridFSBucket(this.db, options);\n      bucket.delete(file.id, cb);\n    }\n  }\n  /**\n   * Pipes the file stream to the MongoDb database. The file requires a property named `file` which is a readable stream\n   * @param {Request} request - The http request where the file was uploaded\n   * @param {File} file - The file stream to pipe\n   * @return  {Promise} Resolves with the uploaded file\n   */\n\n\n  fromFile(request, file) {\n    return this.fromStream(file.stream, request, file);\n  }\n  /**\n   * Pipes the file stream to the MongoDb database. The request and file parameters are optional and used for file generation only\n   * @param {ReadStream} readStream - The http request where the file was uploaded\n   * @param {Request} [request] - The http request where the file was uploaded\n   * @param {File} [file] - The file stream to pipe\n   * @return {Promise} Resolves with the uploaded file\n   */\n\n\n  async fromStream(readStream, request, file) {\n    if (this.connecting) {\n      await this.ready();\n    }\n\n    const fileSettings = await this._generate(request, file);\n    let settings;\n    const setType = typeof fileSettings;\n    const allowedTypes = new Set(['undefined', 'number', 'string', 'object']);\n\n    if (!allowedTypes.has(setType)) {\n      throw new Error('Invalid type for file settings, got ' + setType);\n    }\n\n    if (fileSettings === null || fileSettings === undefined) {\n      settings = {};\n    } else if (setType === 'string' || setType === 'number') {\n      settings = {\n        filename: fileSettings.toString()\n      };\n    } else {\n      settings = fileSettings;\n    }\n\n    const contentType = file ? file.mimetype : undefined;\n    const streamOptions = await GridFSStorage._mergeProps({\n      contentType\n    }, settings);\n    let store;\n    return new Promise((resolve, reject) => {\n      const emitError = streamError => {\n        this.emit('streamError', streamError, streamOptions);\n        reject(streamError);\n      };\n\n      const emitFile = f => {\n        const storedFile = {\n          id: f._id,\n          filename: f.filename,\n          metadata: f.metadata || null,\n          bucketName: streamOptions.bucketName,\n          chunkSize: f.chunkSize,\n          size: f.length,\n          md5: f.md5,\n          uploadDate: f.uploadDate,\n          contentType: f.contentType\n        };\n        this.emit('file', storedFile);\n        resolve(storedFile);\n      };\n\n      const writeStream = this.createStream(streamOptions); // Multer already handles the error event on the readable stream(Busboy).\n      // Invoking the callback with an error will cause file removal and aborting routines to be called twice\n\n      writeStream.on('error', emitError);\n\n      if (this._legacy) {\n        store = writeStream.gs; // In older mongo versions there is a race condition when the store is opening and the stream is\n        // switched into flowing mode that causes the index not to be properly initialized so is better to open the store first\n\n        store.open(error => {\n          if (error) {\n            return emitError(error);\n          }\n\n          writeStream.on('end', () => {\n            store.close((err, f) => {\n              if (err) {\n                return emitError(err);\n              }\n\n              emitFile(f);\n            });\n          });\n          pump(readStream, writeStream);\n        });\n      } else {\n        writeStream.on('finish', emitFile);\n        pump(readStream, writeStream);\n      }\n    });\n  }\n  /**\n   * Tests for generator functions or plain functions and delegates to the appropriate method\n   * @param {Request} request - The request that trigger the upload as received in _handleFile\n   * @param {File} file - The uploaded file stream as received in _handleFile\n   * @return {Promise<any | {}>} A promise with the value generated by the file function\n   **/\n\n\n  async _generate(request, file) {\n    let result;\n    let generator;\n    let isGen = false;\n\n    if (!this._file) {\n      return {};\n    }\n\n    if (isGeneratorFn(this._file)) {\n      isGen = true;\n      generator = this._file(request, file);\n      this._file = generator;\n      result = generator.next();\n    } else if (isGenerator(this._file)) {\n      isGen = true;\n      generator = this._file;\n      result = generator.next([request, file]);\n    } else {\n      result = this._file(request, file);\n    }\n\n    return GridFSStorage._handleResult(result, isGen);\n  }\n  /**\n   * Waits for the MongoDb connection associated to the storage to succeed or fail\n   * @return {Promise<{db: *, client: *}>} Resolves or reject depending on the result of the MongoDb connection\n   */\n\n\n  async ready() {\n    if (this.error) {\n      throw this.error;\n    }\n\n    if (this.connected) {\n      return {\n        db: this.db,\n        client: this.client\n      };\n    }\n\n    return new Promise((resolve, reject) => {\n      const done = result => {\n        this.removeListener('connectionFailed', fail);\n        resolve(result);\n      };\n\n      const fail = err => {\n        this.removeListener('connection', done);\n        reject(err);\n      };\n\n      this.once('connection', done);\n      this.once('connectionFailed', fail);\n    });\n  }\n  /**\n   * Handles generator function and promise results\n   * @param {object} result - Can be a promise or a generator yielded value\n   * @param {boolean} isGen - True if is a yielded value\n   * @return {Promise} The generator value or a plain value wrapped in a Promise\n   * @private\n   **/\n\n\n  static async _handleResult(result, isGen) {\n    let value = result;\n\n    if (isGen) {\n      if (result.done) {\n        throw new Error('Generator ended unexpectedly');\n      }\n\n      value = result.value;\n    }\n\n    return value;\n  }\n  /**\n   * Merge the properties received in the file function with default values\n   * @param extra {object} Extra properties like contentType\n   * @param fileSettings {object} Properties received in the file function\n   * @return {Promise} An object with the merged properties wrapped in a promise\n   * @private\n   */\n\n\n  static async _mergeProps(extra, fileSettings) {\n    // If the filename is not provided generate one\n    const previous = await (fileSettings.filename ? {} : GridFSStorage.generateBytes()); // If no id is provided generate one\n    // If an error occurs the emitted file information will contain the id\n\n    const hasId = fileSettings.id;\n\n    if (!hasId) {\n      previous.id = new ObjectID();\n    }\n\n    return { ...previous,\n      ...defaults,\n      ...extra,\n      ...fileSettings\n    };\n  }\n  /**\n   * Generates 16 bytes long strings in hexadecimal format\n   * @return {Promise<{filename: string}>} A promise containing object with the filename property with the generated string\n   */\n\n\n  static generateBytes() {\n    return new Promise((resolve, reject) => {\n      crypto.randomBytes(16, (err, buffer) => {\n        if (err) {\n          return reject(err);\n        }\n\n        resolve({\n          filename: buffer.toString('hex')\n        });\n      });\n    });\n  }\n\n}\n/**\n * Event emitted when the MongoDb connection is ready to use\n * @event module:multer-gridfs-storage/gridfs~GridFSStorage#connection\n * @param {{db: Db, client: MongoClient}} result - An object containing the mongodb database and client\n * @version 0.0.3\n */\n\n/**\n * Event emitted when the MongoDb connection fails to open\n * @event module:multer-gridfs-storage/gridfs~GridFSStorage#connectionFailed\n * @param {Error} err - The error received when attempting to connect\n * @version 2.0.0\n */\n\n/**\n * Event emitted when a new file is uploaded\n * @event module:multer-gridfs-storage/gridfs~GridFSStorage#file\n * @param {File} file - The uploaded file\n * @version 0.0.3\n */\n\n/**\n * Event emitted when an error occurs streaming to MongoDb\n * @event module:multer-gridfs-storage/gridfs~GridFSStorage#streamError\n * @param {Error} error - The error thrown by the stream\n * @param {Object} conf - The failed file configuration\n * @version 1.3\n */\n\n/**\n * Event emitted when the internal database connection emits an error\n * @event module:multer-gridfs-storage/gridfs~GridFSStorage#dbError\n * @param {Error} error - The error thrown by the database connection\n * @version 1.2.2\n **/\n\n/**\n * The cache used by the module\n * @type {Cache}\n */\n\n\nGridFSStorage.cache = new Cache();\nmodule.exports = new Proxy(GridFSStorage, {\n  apply(target, thisArg, argumentsList) {\n    /* eslint-disable-next-line new-cap */\n    return new target(...argumentsList);\n  }\n\n});","map":{"version":3,"sources":["C:/Users/Yogesh/Desktop/musicplayer/musicapp/musicproject/src/api/node_modules/multer-gridfs-storage/lib/gridfs.js"],"names":["crypto","require","EventEmitter","mongodb","isPromise","isGenerator","isGeneratorFn","fn","pump","mongoUri","getDatabase","Cache","ObjectID","MongoClient","legacy","GridFSBucket","defaults","metadata","chunkSize","bucketName","aliases","GridFSStorage","constructor","configuration","url","db","Error","setMaxListeners","client","connected","connecting","caching","cacheName","cacheIndex","error","_file","file","_legacy","Boolean","cache","_options","options","initialize","init","_connect","_setDb","_resolveConnection","then","catch","_fail","_db","_client","Promise","all","_createConnection","isOpening","isPending","cached","get","opening","waitFor","connect","parsedUri","parse","database","resolve","reject","_updateConnectionStatus","isConnected","topology","errEvent","err","emit","on","process","nextTick","createStream","gfs","settings","GridStore","chunk_size","content_type","contentType","root","id","filename","stream","chunkSizeBytes","disableMD5","openUploadStream","_handleFile","request","cb","ready","fromFile","_removeFile","bucket","unlink","delete","fromStream","readStream","fileSettings","_generate","setType","allowedTypes","Set","has","undefined","toString","mimetype","streamOptions","_mergeProps","store","emitError","streamError","emitFile","f","storedFile","_id","size","length","md5","uploadDate","writeStream","gs","open","close","result","generator","isGen","next","_handleResult","done","removeListener","fail","once","value","extra","previous","generateBytes","hasId","randomBytes","buffer","module","exports","Proxy","apply","target","thisArg","argumentsList"],"mappings":"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","sourcesContent":["/**\n *\n * Plugin definition\n * @module multer-gridfs-storage/gridfs\n *\n */\nconst crypto = require('crypto');\nconst {EventEmitter} = require('events');\nconst mongodb = require('mongodb');\n\nconst isPromise = require('is-promise');\nconst isGenerator = require('is-generator');\nconst isGeneratorFn = isGenerator.fn;\nconst pump = require('pump');\nconst mongoUri = require('mongodb-uri');\nconst {getDatabase} = require('./utils');\nconst Cache = require('./cache');\nconst {ObjectID, MongoClient} = mongodb;\n\n/**\n * Is GridFSBucket present or not\n * @const legacy\n **/\nconst legacy = !mongodb.GridFSBucket;\n\n/**\n * Default file information\n * @const defaults\n **/\nconst defaults = {\n\tmetadata: null,\n\tchunkSize: 261120,\n\tbucketName: 'fs',\n\taliases: null\n};\n\n/**\n * Multer GridFS Storage Engine class definition.\n * @extends EventEmitter\n * @param {object} configuration\n * @param {string} [configuration.url] - The url pointing to a MongoDb database\n * @param {object} [configuration.options] - Options to use when connection with an url.\n * @param {object} [configuration.connectionOpts] - DEPRECATED: Use options instead.\n * @param {boolean | string} [configuration.cache] - Store this connection in the internal cache.\n * @param {Db | Promise} [configuration.db] - The MongoDb database instance to use or a promise that resolves with it\n * @param {Function} [configuration.file] - A function to control the file naming in the database\n * @fires GridFSStorage#connection\n * @fires GridFSStorage#connectionFailed\n * @fires GridFSStorage#file\n * @fires GridFSStorage#streamError\n * @fires GridFSStorage#dbError\n * @version 0.0.3\n */\nclass GridFSStorage extends EventEmitter {\n\tconstructor(configuration) {\n\t\tsuper();\n\n\t\tif (!configuration || (!configuration.url && !configuration.db)) {\n\t\t\tthrow new Error(\n\t\t\t\t'Error creating storage engine. At least one of url or db option must be provided.'\n\t\t\t);\n\t\t}\n\n\t\tthis.setMaxListeners(0);\n\n\t\tthis.db = null;\n\t\tthis.client = null;\n\t\tthis.connected = false;\n\t\tthis.connecting = false;\n\t\tthis.configuration = configuration;\n\t\tthis.caching = false;\n\t\tthis.cacheName = null;\n\t\tthis.cacheIndex = null;\n\t\tthis.error = null;\n\n\t\tthis._file = this.configuration.file;\n\t\tthis._legacy = legacy;\n\n\t\tif (this.configuration.url) {\n\t\t\tthis.caching = Boolean(this.configuration.cache);\n\t\t\tthis._options = this.configuration.options;\n\t\t}\n\n\t\tif (this.caching) {\n\t\t\tthis.cacheName =\n\t\t\t\ttypeof configuration.cache === 'string'\n\t\t\t\t\t? configuration.cache\n\t\t\t\t\t: 'default';\n\t\t\tthis.cacheIndex = GridFSStorage.cache.initialize({\n\t\t\t\turl: configuration.url,\n\t\t\t\tcacheName: this.cacheName,\n\t\t\t\tinit: this._options\n\t\t\t});\n\t\t}\n\n\t\tthis._connect();\n\t}\n\n\t/**\n\t * Determines if a new connection should be created, a explicit connection is provided or a cached instance is required.\n\t * @private\n\t */\n\t_connect() {\n\t\tconst {db, client = null} = this.configuration;\n\n\t\tif (db && !isPromise(db) && !isPromise(client)) {\n\t\t\tthis._setDb(db, client);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._resolveConnection()\n\t\t\t/* eslint-disable-next-line promise/prefer-await-to-then */\n\t\t\t.then(({db, client}) => {\n\t\t\t\tthis._setDb(db, client);\n\t\t\t})\n\t\t\t.catch((error) => this._fail(error));\n\t}\n\n\t/**\n\t * Returns a promise that will resolve to the db and client from the cache or a new connection depending on the provided configuration\n\t * @return {Promise<{client: *, db: *}>}\n\t * @private\n\t */\n\tasync _resolveConnection() {\n\t\tthis.connecting = true;\n\t\tconst {db, client = null} = this.configuration;\n\t\tif (db) {\n\t\t\tconst [_db, _client] = await Promise.all([db, client]);\n\t\t\treturn {db: _db, client: _client};\n\t\t}\n\n\t\tif (!this.caching) {\n\t\t\treturn this._createConnection();\n\t\t}\n\n\t\tconst {cache} = GridFSStorage;\n\t\tif (!cache.isOpening(this.cacheIndex) && cache.isPending(this.cacheIndex)) {\n\t\t\tconst cached = cache.get(this.cacheIndex);\n\t\t\tcached.opening = true;\n\t\t\treturn this._createConnection();\n\t\t}\n\n\t\treturn cache.waitFor(this.cacheIndex);\n\t}\n\n\t/**\n\t * Handles creating a new connection from an url and storing it in the cache if necessary\n\t * @return {Promise<{client: *, db: *}>}\n\t * @private\n\t */\n\tasync _createConnection() {\n\t\tconst {url} = this.configuration;\n\t\tconst {_options: options} = this;\n\n\t\tconst {cache} = GridFSStorage;\n\t\ttry {\n\t\t\tlet db;\n\t\t\tlet client = null;\n\t\t\tconst _db = await MongoClient.connect(url, options);\n\t\t\tlet parsedUri;\n\n\t\t\t// Mongo 3 returns a client instead of a Db object\n\t\t\tif (_db instanceof MongoClient) {\n\t\t\t\tclient = _db;\n\t\t\t\tparsedUri = mongoUri.parse(url);\n\t\t\t\tdb = client.db(parsedUri.database);\n\t\t\t} else {\n\t\t\t\tdb = _db;\n\t\t\t}\n\n\t\t\tif (this.caching) {\n\t\t\t\tcache.resolve(this.cacheIndex, db, client);\n\t\t\t}\n\n\t\t\treturn {db, client};\n\t\t} catch (error) {\n\t\t\tif (this.cacheIndex) {\n\t\t\t\tcache.reject(this.cacheIndex, error);\n\t\t\t}\n\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Updates the connection status based on the internal db or client object\n\t * @private\n\t **/\n\t_updateConnectionStatus() {\n\t\tif (!this.db) {\n\t\t\tthis.connected = false;\n\t\t\tthis.connecting = false;\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.client) {\n\t\t\tthis.connected = this.client.isConnected\n\t\t\t\t? this.client.isConnected()\n\t\t\t\t: true;\n\t\t\treturn;\n\t\t}\n\n\t\tthis.connected = this.db.topology.isConnected();\n\t}\n\n\t/**\n\t * Sets the database connection and emit the connection event\n\t * @param {object} db - Database instance or Mongoose instance to set\n\t * @param {object} [client] - Optional Mongo client for MongoDb v3\n\t * @private\n\t **/\n\t_setDb(db, client) {\n\t\tthis.connecting = false;\n\t\t// Check if the object is a mongoose instance, a mongoose Connection or a mongo Db object\n\t\tthis.db = getDatabase(db);\n\t\tif (client) {\n\t\t\tthis.client = client;\n\t\t}\n\n\t\tconst errEvent = (err) => {\n\t\t\t// Needs verification. Sometimes the event fires without an error object\n\t\t\t// although the docs specify each of the events has a MongoError argument\n\t\t\tthis._updateConnectionStatus();\n\t\t\tconst error = err || new Error();\n\t\t\tthis.emit('dbError', error);\n\t\t};\n\n\t\t// This are all the events that emit errors\n\t\tthis.db\n\t\t\t.on('error', errEvent)\n\t\t\t.on('parseError', errEvent)\n\t\t\t.on('timeout', errEvent)\n\t\t\t.on('close', errEvent);\n\t\tthis._updateConnectionStatus();\n\n\t\t// Emit on next tick so user code can set listeners in case the db object is already available\n\t\tprocess.nextTick(() => {\n\t\t\tthis.emit('connection', {db: this.db, client: this.client});\n\t\t});\n\t}\n\n\t/**\n\t * Removes the database reference and emit the connectionFailed event\n\t * @param {object} err - The error received while trying to connect\n\t * @private\n\t **/\n\t_fail(err) {\n\t\tthis.connecting = false;\n\t\tthis.db = null;\n\t\tthis.client = null;\n\t\tthis.error = err;\n\t\tthis._updateConnectionStatus();\n\t\t// Fail event is only emitted after either a then promise handler or an I/O phase so is guaranteed to be asynchronous\n\t\tthis.emit('connectionFailed', err);\n\t}\n\n\t/**\n\t * Create a writable stream with backwards compatibility with GridStore\n\t * @param {object} options - The stream options\n\t * @return {GridStoreStream | GridFSBucketWriteStream}\n\t */\n\tcreateStream(options) {\n\t\tlet gfs;\n\t\tlet settings;\n\t\tconst {GridStore} = mongodb;\n\t\tconst {GridFSBucket} = mongodb;\n\n\t\tif (this._legacy) {\n\t\t\t// `disableMD5` is not supported in GridStore\n\t\t\tsettings = {\n\t\t\t\t/* eslint-disable-next-line camelcase */\n\t\t\t\tchunk_size: options.chunkSize,\n\t\t\t\tmetadata: options.metadata,\n\t\t\t\t/* eslint-disable-next-line camelcase */\n\t\t\t\tcontent_type: options.contentType,\n\t\t\t\troot: options.bucketName,\n\t\t\t\taliases: options.aliases\n\t\t\t};\n\t\t\tgfs = new GridStore(this.db, options.id, options.filename, 'w', settings);\n\t\t\treturn gfs.stream();\n\t\t}\n\n\t\tsettings = {\n\t\t\tid: options.id,\n\t\t\tchunkSizeBytes: options.chunkSize,\n\t\t\tcontentType: options.contentType,\n\t\t\tmetadata: options.metadata,\n\t\t\taliases: options.aliases,\n\t\t\tdisableMD5: options.disableMD5\n\t\t};\n\t\tgfs = new GridFSBucket(this.db, {bucketName: options.bucketName});\n\t\treturn gfs.openUploadStream(options.filename, settings);\n\t}\n\n\t/**\n\t * Storage interface method to handle incoming files\n\t * @param {Request} request - The request that trigger the upload\n\t * @param {File} file - The uploaded file stream\n\t * @param {function} cb - A standard node callback to signal the end of the upload or an error\n\t **/\n\t_handleFile(request, file, cb) {\n\t\tif (this.connecting) {\n\t\t\tthis.ready()\n\t\t\t\t/* eslint-disable-next-line promise/prefer-await-to-then */\n\t\t\t\t.then(() => this.fromFile(request, file))\n\t\t\t\t/* eslint-disable-next-line promise/prefer-await-to-then */\n\t\t\t\t.then((file) => cb(null, file))\n\t\t\t\t.catch(cb);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._updateConnectionStatus();\n\t\tif (this.connected) {\n\t\t\tthis.fromFile(request, file)\n\t\t\t\t/* eslint-disable-next-line promise/prefer-await-to-then */\n\t\t\t\t.then((file) => cb(null, file))\n\t\t\t\t.catch(cb);\n\t\t\treturn;\n\t\t}\n\n\t\tcb(new Error('The database connection must be open to store files'));\n\t}\n\n\t/**\n\t * Storage interface method to delete files in case an error turns the request invalid\n\t * @param {Request} request - The request that trigger the upload\n\t * @param {File} file - The uploaded file stream\n\t * @param {function} cb - A standard node callback to signal the end of the upload or an error\n\t **/\n\t_removeFile(request, file, cb) {\n\t\tlet bucket;\n\t\tlet options;\n\t\tconst {GridStore} = mongodb;\n\t\tconst {GridFSBucket} = mongodb;\n\n\t\tif (this._legacy) {\n\t\t\toptions = {root: file.bucketName};\n\t\t\tGridStore.unlink(this.db, file.id, options, cb);\n\t\t} else {\n\t\t\toptions = {bucketName: file.bucketName};\n\t\t\tbucket = new GridFSBucket(this.db, options);\n\t\t\tbucket.delete(file.id, cb);\n\t\t}\n\t}\n\n\t/**\n\t * Pipes the file stream to the MongoDb database. The file requires a property named `file` which is a readable stream\n\t * @param {Request} request - The http request where the file was uploaded\n\t * @param {File} file - The file stream to pipe\n\t * @return  {Promise} Resolves with the uploaded file\n\t */\n\tfromFile(request, file) {\n\t\treturn this.fromStream(file.stream, request, file);\n\t}\n\n\t/**\n\t * Pipes the file stream to the MongoDb database. The request and file parameters are optional and used for file generation only\n\t * @param {ReadStream} readStream - The http request where the file was uploaded\n\t * @param {Request} [request] - The http request where the file was uploaded\n\t * @param {File} [file] - The file stream to pipe\n\t * @return {Promise} Resolves with the uploaded file\n\t */\n\tasync fromStream(readStream, request, file) {\n\t\tif (this.connecting) {\n\t\t\tawait this.ready();\n\t\t}\n\n\t\tconst fileSettings = await this._generate(request, file);\n\t\tlet settings;\n\t\tconst setType = typeof fileSettings;\n\t\tconst allowedTypes = new Set(['undefined', 'number', 'string', 'object']);\n\t\tif (!allowedTypes.has(setType)) {\n\t\t\tthrow new Error('Invalid type for file settings, got ' + setType);\n\t\t}\n\n\t\tif (fileSettings === null || fileSettings === undefined) {\n\t\t\tsettings = {};\n\t\t} else if (setType === 'string' || setType === 'number') {\n\t\t\tsettings = {\n\t\t\t\tfilename: fileSettings.toString()\n\t\t\t};\n\t\t} else {\n\t\t\tsettings = fileSettings;\n\t\t}\n\n\t\tconst contentType = file ? file.mimetype : undefined;\n\t\tconst streamOptions = await GridFSStorage._mergeProps(\n\t\t\t{contentType},\n\t\t\tsettings\n\t\t);\n\t\tlet store;\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst emitError = (streamError) => {\n\t\t\t\tthis.emit('streamError', streamError, streamOptions);\n\t\t\t\treject(streamError);\n\t\t\t};\n\n\t\t\tconst emitFile = (f) => {\n\t\t\t\tconst storedFile = {\n\t\t\t\t\tid: f._id,\n\t\t\t\t\tfilename: f.filename,\n\t\t\t\t\tmetadata: f.metadata || null,\n\t\t\t\t\tbucketName: streamOptions.bucketName,\n\t\t\t\t\tchunkSize: f.chunkSize,\n\t\t\t\t\tsize: f.length,\n\t\t\t\t\tmd5: f.md5,\n\t\t\t\t\tuploadDate: f.uploadDate,\n\t\t\t\t\tcontentType: f.contentType\n\t\t\t\t};\n\t\t\t\tthis.emit('file', storedFile);\n\t\t\t\tresolve(storedFile);\n\t\t\t};\n\n\t\t\tconst writeStream = this.createStream(streamOptions);\n\n\t\t\t// Multer already handles the error event on the readable stream(Busboy).\n\t\t\t// Invoking the callback with an error will cause file removal and aborting routines to be called twice\n\t\t\twriteStream.on('error', emitError);\n\n\t\t\tif (this._legacy) {\n\t\t\t\tstore = writeStream.gs;\n\t\t\t\t// In older mongo versions there is a race condition when the store is opening and the stream is\n\t\t\t\t// switched into flowing mode that causes the index not to be properly initialized so is better to open the store first\n\t\t\t\tstore.open((error) => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\treturn emitError(error);\n\t\t\t\t\t}\n\n\t\t\t\t\twriteStream.on('end', () => {\n\t\t\t\t\t\tstore.close((err, f) => {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\treturn emitError(err);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\temitFile(f);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t\tpump(readStream, writeStream);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\twriteStream.on('finish', emitFile);\n\t\t\t\tpump(readStream, writeStream);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Tests for generator functions or plain functions and delegates to the appropriate method\n\t * @param {Request} request - The request that trigger the upload as received in _handleFile\n\t * @param {File} file - The uploaded file stream as received in _handleFile\n\t * @return {Promise<any | {}>} A promise with the value generated by the file function\n\t **/\n\tasync _generate(request, file) {\n\t\tlet result;\n\t\tlet generator;\n\t\tlet isGen = false;\n\n\t\tif (!this._file) {\n\t\t\treturn {};\n\t\t}\n\n\t\tif (isGeneratorFn(this._file)) {\n\t\t\tisGen = true;\n\t\t\tgenerator = this._file(request, file);\n\t\t\tthis._file = generator;\n\t\t\tresult = generator.next();\n\t\t} else if (isGenerator(this._file)) {\n\t\t\tisGen = true;\n\t\t\tgenerator = this._file;\n\t\t\tresult = generator.next([request, file]);\n\t\t} else {\n\t\t\tresult = this._file(request, file);\n\t\t}\n\n\t\treturn GridFSStorage._handleResult(result, isGen);\n\t}\n\n\t/**\n\t * Waits for the MongoDb connection associated to the storage to succeed or fail\n\t * @return {Promise<{db: *, client: *}>} Resolves or reject depending on the result of the MongoDb connection\n\t */\n\tasync ready() {\n\t\tif (this.error) {\n\t\t\tthrow this.error;\n\t\t}\n\n\t\tif (this.connected) {\n\t\t\treturn {db: this.db, client: this.client};\n\t\t}\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst done = (result) => {\n\t\t\t\tthis.removeListener('connectionFailed', fail);\n\t\t\t\tresolve(result);\n\t\t\t};\n\n\t\t\tconst fail = (err) => {\n\t\t\t\tthis.removeListener('connection', done);\n\t\t\t\treject(err);\n\t\t\t};\n\n\t\t\tthis.once('connection', done);\n\t\t\tthis.once('connectionFailed', fail);\n\t\t});\n\t}\n\n\t/**\n\t * Handles generator function and promise results\n\t * @param {object} result - Can be a promise or a generator yielded value\n\t * @param {boolean} isGen - True if is a yielded value\n\t * @return {Promise} The generator value or a plain value wrapped in a Promise\n\t * @private\n\t **/\n\tstatic async _handleResult(result, isGen) {\n\t\tlet value = result;\n\n\t\tif (isGen) {\n\t\t\tif (result.done) {\n\t\t\t\tthrow new Error('Generator ended unexpectedly');\n\t\t\t}\n\n\t\t\tvalue = result.value;\n\t\t}\n\n\t\treturn value;\n\t}\n\n\t/**\n\t * Merge the properties received in the file function with default values\n\t * @param extra {object} Extra properties like contentType\n\t * @param fileSettings {object} Properties received in the file function\n\t * @return {Promise} An object with the merged properties wrapped in a promise\n\t * @private\n\t */\n\tstatic async _mergeProps(extra, fileSettings) {\n\t\t// If the filename is not provided generate one\n\t\tconst previous = await (fileSettings.filename\n\t\t\t? {}\n\t\t\t: GridFSStorage.generateBytes());\n\t\t// If no id is provided generate one\n\t\t// If an error occurs the emitted file information will contain the id\n\t\tconst hasId = fileSettings.id;\n\t\tif (!hasId) {\n\t\t\tprevious.id = new ObjectID();\n\t\t}\n\n\t\treturn {...previous, ...defaults, ...extra, ...fileSettings};\n\t}\n\n\t/**\n\t * Generates 16 bytes long strings in hexadecimal format\n\t * @return {Promise<{filename: string}>} A promise containing object with the filename property with the generated string\n\t */\n\tstatic generateBytes() {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tcrypto.randomBytes(16, (err, buffer) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn reject(err);\n\t\t\t\t}\n\n\t\t\t\tresolve({filename: buffer.toString('hex')});\n\t\t\t});\n\t\t});\n\t}\n}\n\n/**\n * Event emitted when the MongoDb connection is ready to use\n * @event module:multer-gridfs-storage/gridfs~GridFSStorage#connection\n * @param {{db: Db, client: MongoClient}} result - An object containing the mongodb database and client\n * @version 0.0.3\n */\n\n/**\n * Event emitted when the MongoDb connection fails to open\n * @event module:multer-gridfs-storage/gridfs~GridFSStorage#connectionFailed\n * @param {Error} err - The error received when attempting to connect\n * @version 2.0.0\n */\n\n/**\n * Event emitted when a new file is uploaded\n * @event module:multer-gridfs-storage/gridfs~GridFSStorage#file\n * @param {File} file - The uploaded file\n * @version 0.0.3\n */\n\n/**\n * Event emitted when an error occurs streaming to MongoDb\n * @event module:multer-gridfs-storage/gridfs~GridFSStorage#streamError\n * @param {Error} error - The error thrown by the stream\n * @param {Object} conf - The failed file configuration\n * @version 1.3\n */\n\n/**\n * Event emitted when the internal database connection emits an error\n * @event module:multer-gridfs-storage/gridfs~GridFSStorage#dbError\n * @param {Error} error - The error thrown by the database connection\n * @version 1.2.2\n **/\n\n/**\n * The cache used by the module\n * @type {Cache}\n */\nGridFSStorage.cache = new Cache();\n\nmodule.exports = new Proxy(GridFSStorage, {\n\tapply(target, thisArg, argumentsList) {\n\t\t/* eslint-disable-next-line new-cap */\n\t\treturn new target(...argumentsList);\n\t}\n});\n"]},"metadata":{},"sourceType":"module"}