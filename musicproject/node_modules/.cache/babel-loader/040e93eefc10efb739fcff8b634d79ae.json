{"ast":null,"code":"let fs = require(\"fs\");\n\nlet assert = require(\"assert\");\n\nvar path = require('path');\n\nlet express = require(\"express\");\n\nlet router = express.Router();\n\nvar crypto = require('crypto');\n\nvar multer = require('multer');\n\nvar mongoose = require(\"mongoose\");\n\nvar mongodb = require(\"mongodb\");\n\nvar GridFsStorage = require('multer-gridfs-storage');\n\nvar Grid = require('gridfs-stream');\n\nvar MethodOverride = require('method-override');\n\nconst {\n  Console\n} = require(\"console\");\n\nconst {\n  stringify\n} = require(\"querystring\");\n\nconst uri = \"mongodb+srv://yogesh-negi:Yogeshnegi@123@cluster0.etu5e.mongodb.net/songs?retryWrites=true&w=majority\";\nmongoose.connect(uri, {\n  useNewUrlParser: true,\n  useCreateIndex: true,\n  useUnifiedTopology: true\n}).then(() => console.log('Database Connected')).catch(err => console.log(err));\nlet songSchema = new mongoose.Schema({\n  playlistname: String,\n  cover: String,\n  Name: Array,\n  year: Number\n});\nlet songmodel = mongoose.model(\"songschema\", songSchema);\nvar storage = multer.diskStorage({\n  destination: \"./public/uploads\",\n  filename: function (req, file, cb) {\n    cb(null, file.originalname);\n  }\n});\nlet upload = multer({\n  storage: storage\n}).single(\"file\");\nrouter.post(\"/\", (req, res) => {\n  upload(req, res, err => {\n    if (err) {\n      console.log(err);\n    } else {\n      mongodb.MongoClient.connect(uri, (err, client) => {\n        assert.ifError(err);\n        const db = client.db(\"sadsongs\");\n        var bucket = new mongodb.GridFSBucket(db);\n        fs.createReadStream(\"./public/uploads/\" + req.file.filename).pipe(bucket.openUploadStream(req.file.filename)).on(\"error\", error => {\n          assert.ifError(error);\n        }).on(\"finish\", () => {\n          console.log(\"done !!\");\n        }); // .bucket.openDownloadStreamByName(songname).\n        // pipe(fs.createWriteStream('./playedsongs/'+songname)).\n        // on('error', (error) => {\n        //    assert.ifError(error);\n        // }).\n        // on(\"finish\", () => {\n        //    console.log('downloaded !');\n        // })\n      });\n      let newmodel = new songmodel(JSON.parse(req.body.body));\n      newmodel.Name = req.file.filename;\n      newmodel.save(error => {\n        if (error) {\n          console.log('something went wrong');\n        } else {\n          console.log('data has been saved');\n        }\n      });\n      res.send(`http://localhost:4000/${req.file.filename}`);\n    }\n  });\n});\nrouter.get(\"/\", (req, res) => {\n  //   let readdir = fs.readdirSync(\"./public/uploads\")\n  //  res.send(readdir)\n  songmodel.find({}).then(data => res.send(data));\n}); // let Schema = mongoose.Schema\n// let blogpostschma = new Schema({\n//  name:String,\n// email:String,\n// text:String,\n// date:Object,\n// })\n//  let blogpost = mongoose.model(\"comments\", blogpostschma)\n// let data = {\n//    title:\"hey this is my first script\"\n// }\n// const newblogpost = new blogpost(data)\n// newblogpost.save(error => {\n//    if(error){\n//       console.log(\"something went wrong\")\n//    } else {\n//       console.log(\"data has been saved\")\n//    }\n// })\n//  router.get(\"/\", (req, res, next)=>{\n//    //  let readsongdirt = fs.readdirSync(\"../audio\")\n//    //  let songarray = []\n//    //  readsongdirt.forEach(data => songarray.push([data.replace(\".mp3\", \"\")]))\n//    //  let writefile = fs.writeFileSync(__dirname+\"/test.json\",JSON.stringify(songarray))\n//    //  let readdata = fs.readFileSync(__dirname+\"/test.json\",\"utf8\")\n//    //  let parseddata = JSON.parse(readdata)   \n//    //  res.writeHead(200,{\"content-type\":\"application/json\"})\n//    //  res.end(JSON.stringify(parseddata))\n//     blogpost.find({ }).then(data => res.end(data.toString()))\n//  })\n// router.post(\"/\", (req, res)=>{\n// function Playlist (playlistname,cover,Name,year){\n// this.playlistname = playlistname,\n// this.cover = cover,\n// this.Name = Name,\n// this.year = year  \n// }\n// let NewPlaylist = new Playlist(...Object.values(req.body))\n// let songsarray = NewPlaylist.Name\n// let yeararray = NewPlaylist.year.split(\",\")\n// let playlistobject = {}\n// playlistobject[NewPlaylist.playlistname] = [{PlaylistName:NewPlaylist.playlistname,\n// cover:NewPlaylist.cover,\n// Songs:[]\n// }]\n// songsarray.forEach((val,i)=>{\n//    return playlistobject[NewPlaylist.playlistname][0].Songs.push({\"Name\":val,Year:yeararray[i]})\n//    })\n// let readfile = JSON.parse(fs.readFileSync(\"../Components/data.json\", \"utf8\"))\n// readfile.push(playlistobject)\n// let writefile = fs.writeFileSync(\"../Components/data.json\", JSON.stringify(readfile))\n//    res.end(JSON.stringify(playlistobject))\n// })\n\nmodule.exports = router;","map":{"version":3,"sources":["C:/Users/Yogesh/Desktop/musicplayer/musicapp/musicproject/src/api/routes/testApi.js"],"names":["fs","require","assert","path","express","router","Router","crypto","multer","mongoose","mongodb","GridFsStorage","Grid","MethodOverride","Console","stringify","uri","connect","useNewUrlParser","useCreateIndex","useUnifiedTopology","then","console","log","catch","err","songSchema","Schema","playlistname","String","cover","Name","Array","year","Number","songmodel","model","storage","diskStorage","destination","filename","req","file","cb","originalname","upload","single","post","res","MongoClient","client","ifError","db","bucket","GridFSBucket","createReadStream","pipe","openUploadStream","on","error","newmodel","JSON","parse","body","save","send","get","find","data","module","exports"],"mappings":"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","sourcesContent":["let fs = require(\"fs\");\r\nlet assert = require(\"assert\")\r\nvar path = require('path');\r\nlet express = require(\"express\");\r\nlet router = express.Router();\r\nvar crypto = require('crypto');\r\nvar multer = require('multer');\r\nvar mongoose = require(\"mongoose\");\r\nvar mongodb = require(\"mongodb\");\r\nvar GridFsStorage = require('multer-gridfs-storage');\r\nvar Grid = require('gridfs-stream');\r\nvar MethodOverride = require('method-override');\r\nconst { Console } = require(\"console\");\r\nconst { stringify } = require(\"querystring\");\r\n\r\nconst uri = \"mongodb+srv://yogesh-negi:Yogeshnegi@123@cluster0.etu5e.mongodb.net/songs?retryWrites=true&w=majority\";\r\n\r\nmongoose\r\n     .connect( uri, { useNewUrlParser: true, useCreateIndex: true, useUnifiedTopology: true })\r\n     .then(() => console.log( 'Database Connected'))\r\n     .catch(err => console.log( err ));\r\n\r\n\r\n\r\n\r\n\r\n\r\nlet songSchema = new mongoose.Schema({\r\n  playlistname:String,\r\n  cover:String,\r\n  Name:Array,\r\n  year:Number\r\n})\r\n\r\nlet songmodel = mongoose.model(\"songschema\", songSchema)\r\n\r\nvar storage = multer.diskStorage({\r\n   destination:\"./public/uploads\",\r\n   filename:function(req, file, cb){\r\n     cb(null, file.originalname)\r\n   }\r\n })\r\n \r\n let upload = multer({\r\n   storage:storage,\r\n }).single(\"file\")\r\n \r\n \r\n   router.post(\"/\" , (req, res)=>{\r\n\r\n    upload(req, res, (err)=>{\r\n       if(err){\r\n         console.log(err);\r\n       } else {\r\n        \r\n        mongodb.MongoClient.connect(uri, (err, client)=>{\r\n          assert.ifError(err);\r\n          const db = client.db(\"sadsongs\")\r\n          var bucket = new mongodb.GridFSBucket(db);\r\n          \r\n          fs.createReadStream(\"./public/uploads/\"+req.file.filename).\r\n          pipe(bucket.openUploadStream(req.file.filename)).\r\n          on(\"error\", (error)=>{\r\n          assert.ifError(error);\r\n          }).\r\n          on(\"finish\", ()=>{\r\n             console.log(\"done !!\");\r\n          })\r\n          // .bucket.openDownloadStreamByName(songname).\r\n          // pipe(fs.createWriteStream('./playedsongs/'+songname)).\r\n          // on('error', (error) => {\r\n          //    assert.ifError(error);\r\n          // }).\r\n          // on(\"finish\", () => {\r\n          //    console.log('downloaded !');\r\n          // })\r\n          \r\n          \r\n          })\r\n          let newmodel = new songmodel(JSON.parse(req.body.body))\r\n          newmodel.Name = req.file.filename\r\n          newmodel.save(error => {\r\n            if(error){\r\n              console.log('something went wrong')\r\n            } else {\r\n              console.log('data has been saved')\r\n            }\r\n          })\r\n         res.send(`http://localhost:4000/${req.file.filename}`)\r\n       }\r\n   })\r\n   })\r\n\r\n   router.get(\"/\", (req, res)=>{\r\n  //   let readdir = fs.readdirSync(\"./public/uploads\")\r\n  //  res.send(readdir)\r\n  songmodel.find({ }).then(data => res.send(data))\r\n   })\r\n\r\n\r\n\r\n\r\n\r\n// let Schema = mongoose.Schema\r\n// let blogpostschma = new Schema({\r\n//  name:String,\r\n// email:String,\r\n// text:String,\r\n// date:Object,\r\n// })\r\n\r\n//  let blogpost = mongoose.model(\"comments\", blogpostschma)\r\n// let data = {\r\n//    title:\"hey this is my first script\"\r\n// }\r\n\r\n// const newblogpost = new blogpost(data)\r\n\r\n\r\n// newblogpost.save(error => {\r\n//    if(error){\r\n//       console.log(\"something went wrong\")\r\n//    } else {\r\n//       console.log(\"data has been saved\")\r\n//    }\r\n// })\r\n\r\n//  router.get(\"/\", (req, res, next)=>{\r\n//    //  let readsongdirt = fs.readdirSync(\"../audio\")\r\n//    //  let songarray = []\r\n//    //  readsongdirt.forEach(data => songarray.push([data.replace(\".mp3\", \"\")]))\r\n//    //  let writefile = fs.writeFileSync(__dirname+\"/test.json\",JSON.stringify(songarray))\r\n//    //  let readdata = fs.readFileSync(__dirname+\"/test.json\",\"utf8\")\r\n//    //  let parseddata = JSON.parse(readdata)   \r\n//    //  res.writeHead(200,{\"content-type\":\"application/json\"})\r\n//    //  res.end(JSON.stringify(parseddata))\r\n//     blogpost.find({ }).then(data => res.end(data.toString()))\r\n//  })\r\n\r\n// router.post(\"/\", (req, res)=>{\r\n\r\n\r\n// function Playlist (playlistname,cover,Name,year){\r\n// this.playlistname = playlistname,\r\n// this.cover = cover,\r\n// this.Name = Name,\r\n// this.year = year  \r\n// }\r\n\r\n// let NewPlaylist = new Playlist(...Object.values(req.body))\r\n\r\n// let songsarray = NewPlaylist.Name\r\n// let yeararray = NewPlaylist.year.split(\",\")\r\n\r\n// let playlistobject = {}\r\n\r\n// playlistobject[NewPlaylist.playlistname] = [{PlaylistName:NewPlaylist.playlistname,\r\n// cover:NewPlaylist.cover,\r\n// Songs:[]\r\n// }]\r\n\r\n// songsarray.forEach((val,i)=>{\r\n//    return playlistobject[NewPlaylist.playlistname][0].Songs.push({\"Name\":val,Year:yeararray[i]})\r\n//    })\r\n\r\n\r\n// let readfile = JSON.parse(fs.readFileSync(\"../Components/data.json\", \"utf8\"))\r\n// readfile.push(playlistobject)\r\n// let writefile = fs.writeFileSync(\"../Components/data.json\", JSON.stringify(readfile))\r\n\r\n//    res.end(JSON.stringify(playlistobject))\r\n// })\r\n\r\n\r\n\r\nmodule.exports = router"]},"metadata":{},"sourceType":"module"}