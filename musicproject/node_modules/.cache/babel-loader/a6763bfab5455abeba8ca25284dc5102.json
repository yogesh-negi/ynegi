{"ast":null,"code":"/**\n * Module dependencies\n */\nvar util = require('util');\n\nvar Readable = require('stream').Readable;\n/**\n * expose\n * @ignore\n */\n\n\nmodule.exports = exports = GridReadStream;\n/**\n * GridReadStream\n *\n * @param {Grid} grid\n * @param {Object} options\n */\n\nfunction GridReadStream(grid, options) {\n  if (!(this instanceof GridReadStream)) return new GridReadStream(grid, options);\n  Readable.call(this);\n  this._opened = false;\n  this._opening = false;\n  this._closing = false;\n  this._end = false;\n  this._needToPush = false;\n  this._grid = grid; // a bit backwards compatible\n\n  if (typeof options === 'string') {\n    options = {\n      filename: options\n    };\n  }\n\n  this.options = options || {};\n\n  if (options._id) {\n    this.id = grid.tryParseObjectId(options._id);\n\n    if (!this.id) {\n      this.id = options._id;\n    }\n  }\n\n  this.name = this.options.filename || '';\n  this.mode = 'r'; // If chunk size specified use it for read chunk size otherwise default to 255k (GridStore default). chunkSize and chunk_size in mongodb api so check both.\n\n  this._chunkSize = this.options.chunkSize || this.options.chunk_size || 1024 * 255;\n  this.range = this.options.range || {\n    startPos: 0,\n    endPos: undefined\n  };\n\n  if (typeof this.range.startPos === 'undefined') {\n    this.range.startPos = 0;\n  }\n\n  this._currentPos = this.range.startPos;\n  var options = {};\n\n  for (var i in this.options) {\n    options[i] = this.options[i];\n  }\n\n  options.root || (options.root = this._grid.curCol);\n  this._store = new grid.mongo.GridStore(grid.db, this.id || new grid.mongo.ObjectID(), this.name, this.mode, options); // Workaround for Gridstore issue https://github.com/mongodb/node-mongodb-native/pull/930\n\n  if (!this.id) {\n    // var REFERENCE_BY_FILENAME = 0,\n    this._store.referenceBy = 0;\n  }\n\n  var self = this; //Close the store once `end` received\n\n  this.on('end', function () {\n    self._end = true;\n\n    self._close();\n  });\n  process.nextTick(function () {\n    self._open();\n  });\n}\n/**\n * Inherit from stream.Readable\n * @ignore\n */\n\n\n_c = GridReadStream;\nutil.inherits(GridReadStream, Readable);\n/**\n * _open\n *\n * @api private\n */\n\nGridReadStream.prototype._open = function _open() {\n  if (this._opening) return;\n  this._opening = true;\n  var self = this; // Open the sore\n\n  this._store.open(function (err, gs) {\n    if (err) return self._error(err); // Find the length of the file by setting the head to the end of the file and requesting the position\n\n    self._store.seek(0, self._grid.mongo.GridStore.IO_SEEK_END, function (err) {\n      if (err) return self._error(err); // Request the position of the end of the file\n\n      self._store.tell(function (err, position) {\n        if (err) return self._error(err); // Calculate the correct end position either from EOF or end of range. Also handle incorrect range request.\n\n        if (!self.range.endPos || self.range.endPos > position - 1) {\n          self.range.endPos = position - 1;\n        }\n\n        ; // Set the read head to the beginning of the file or start position if specified\n\n        self._store.seek(self.range.startPos, self._grid.mongo.GridStore.IO_SEEK_SET, function (err) {\n          if (err) return self._error(err); // The store is now open\n\n          self.emit('open');\n          self._opened = true; // If `_read()` was already called then we need to start pushing data to the stream. Otherwise `_read()` will handle this once called from stream.\n\n          if (self._needToPush) self._push();\n        });\n      });\n    });\n  });\n};\n/**\n * _read\n *\n * @api private\n */\n// `_read()` will be called when the stream wants to pull more data in\n// The advisory `size` argument is ignored in this case and user specified use or default to 255kk.\n\n\nGridReadStream.prototype._read = function _read(size) {\n  var self = this; // Set `_needToPush` to true because the store may still be closed if data is immediately piped. Once the store is open `_needToPush` is checked and _push() called if necessary.\n\n  self._needToPush = true; // The store must be open\n\n  if (!this._opened) return; // Read data from GridStore and push to stream\n\n  self._push();\n};\n/**\n * _push\n *\n * @api private\n */\n\n\nGridReadStream.prototype._push = function _push() {\n  var self = this; // Do not continue if the store is closed\n\n  if (!this._opened) return self._error('Unable to push data. Expected gridstore to be open'); // Check if EOF, if the full requested range has been pushed or if the stream must be destroyed. If so than push EOF-signalling `null` chunk\n\n  if (!this._store.eof() && self._currentPos <= self.range.endPos && !this._end) {\n    // Determine the chunk size for the read from GridStore\n    // Use default chunk size or user specified\n    var readChunkSize = self._chunkSize; // Override the chunk size if the chunk size is more than the size that is left until EOF/range\n\n    if (self.range.endPos - self._currentPos < self._chunkSize) {\n      readChunkSize = self.range.endPos - self._currentPos + 1;\n    }\n\n    ; // Read the chunk from GridSore. Head moves automatically after each read.\n\n    self._store.read(readChunkSize, function (err, data) {\n      // If error stop and close the store\n      if (err) return self._error(err); // Advance the current position of the read head\n\n      self._currentPos += data.length; // Push data\n\n      if (!self._end) self.push(data);\n    });\n  } else {\n    // Push EOF-signalling `null` chunk\n    this._end = true;\n    self.push(null);\n  }\n};\n/**\n * _close\n *\n * @api private\n */\n\n\nGridReadStream.prototype._close = function _close() {\n  var self = this;\n  if (!self._opened) return;\n  if (self._closing) return;\n  this._closing = true; // Close the store and emit `close` event\n\n  self._store.close(function (err) {\n    if (err) return self._error(err);\n    self.emit('close');\n  });\n};\n/**\n * _error\n *\n * @api private\n */\n\n\nGridReadStream.prototype._error = function _error(err) {\n  // Set end true so that no further reads from GridSotre are possible and close the store\n  this._end = true; // Emit the error event\n\n  this.emit('error', err); // Close the gridsore if an error is received.\n\n  this._close();\n};\n/**\n * destroy\n *\n * @api public\n */\n\n\nGridReadStream.prototype.destroy = function destroy() {\n  // Set end true so that no further reads from GridSotre are possible and close the store\n  this._end = true;\n\n  this._close();\n};\n\nvar _c;\n\n$RefreshReg$(_c, \"GridReadStream\");","map":{"version":3,"sources":["C:/Users/Yogesh/Desktop/musicplayer/musicapp/musicproject/src/api/node_modules/gridfs-stream/lib/readstream.js"],"names":["util","require","Readable","module","exports","GridReadStream","grid","options","call","_opened","_opening","_closing","_end","_needToPush","_grid","filename","_id","id","tryParseObjectId","name","mode","_chunkSize","chunkSize","chunk_size","range","startPos","endPos","undefined","_currentPos","i","root","curCol","_store","mongo","GridStore","db","ObjectID","referenceBy","self","on","_close","process","nextTick","_open","inherits","prototype","open","err","gs","_error","seek","IO_SEEK_END","tell","position","IO_SEEK_SET","emit","_push","_read","size","eof","readChunkSize","read","data","length","push","close","destroy"],"mappings":"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","sourcesContent":["\n/**\n * Module dependencies\n */\n\nvar util = require('util');\nvar Readable  = require('stream').Readable;\n\n/**\n * expose\n * @ignore\n */\n\nmodule.exports = exports = GridReadStream;\n\n/**\n * GridReadStream\n *\n * @param {Grid} grid\n * @param {Object} options\n */\n\nfunction GridReadStream (grid, options) {\n  if (!(this instanceof GridReadStream))\n    return new GridReadStream(grid, options);\n\n  Readable.call(this);\n  this._opened = false;\n  this._opening = false;\n  this._closing = false;\n  this._end = false;\n  this._needToPush = false;\n\n  this._grid = grid;\n\n  // a bit backwards compatible\n  if (typeof options === 'string') {\n    options = { filename: options };\n  }\n\n  this.options = options || {};\n\n  if(options._id) {\n    this.id = grid.tryParseObjectId(options._id);\n\n    if(!this.id) {\n      this.id = options._id;\n    }\n  }\n\n  this.name = this.options.filename || '';\n  this.mode = 'r';\n\n  // If chunk size specified use it for read chunk size otherwise default to 255k (GridStore default). chunkSize and chunk_size in mongodb api so check both.\n  this._chunkSize = this.options.chunkSize || this.options.chunk_size || 1024 * 255;\n\n  this.range = this.options.range || { startPos: 0, endPos: undefined };\n  if (typeof(this.range.startPos) === 'undefined') {\n    this.range.startPos = 0;\n  }\n\n  this._currentPos = this.range.startPos;\n\n  var options = {};\n  for (var i in this.options) { options[i] = this.options[i]; }\n  options.root || (options.root = this._grid.curCol);\n\n  this._store = new grid.mongo.GridStore(grid.db, this.id || new grid.mongo.ObjectID(), this.name, this.mode, options);\n  // Workaround for Gridstore issue https://github.com/mongodb/node-mongodb-native/pull/930\n  if (!this.id) {\n    // var REFERENCE_BY_FILENAME = 0,\n    this._store.referenceBy = 0;\n  }\n\n  var self = this;\n\n  //Close the store once `end` received\n  this.on('end', function() {\n    self._end = true;\n    self._close()\n  });\n\n  process.nextTick(function() {\n    self._open();\n  });\n}\n\n/**\n * Inherit from stream.Readable\n * @ignore\n */\n\nutil.inherits(GridReadStream, Readable);\n\n/**\n * _open\n *\n * @api private\n */\n\nGridReadStream.prototype._open = function _open () {\n  if (this._opening) return;\n  this._opening = true;\n\n  var self = this;\n\n  // Open the sore\n  this._store.open(function (err, gs) {\n    if (err) return self._error(err);\n\n    // Find the length of the file by setting the head to the end of the file and requesting the position\n    self._store.seek(0, self._grid.mongo.GridStore.IO_SEEK_END, function(err) {\n        if (err) return self._error(err);\n\n        // Request the position of the end of the file\n        self._store.tell(function(err, position) {\n        if (err) return self._error(err);\n\n            // Calculate the correct end position either from EOF or end of range. Also handle incorrect range request.\n            if (!self.range.endPos || self.range.endPos > position-1) {self.range.endPos = position - 1};\n\n            // Set the read head to the beginning of the file or start position if specified\n            self._store.seek(self.range.startPos, self._grid.mongo.GridStore.IO_SEEK_SET, function(err) {\n              if (err) return self._error(err);\n\n              // The store is now open\n              self.emit('open');\n              self._opened = true;\n\n              // If `_read()` was already called then we need to start pushing data to the stream. Otherwise `_read()` will handle this once called from stream.\n              if (self._needToPush) self._push();\n            });\n        });\n    });\n  });\n}\n\n/**\n * _read\n *\n * @api private\n */\n\n// `_read()` will be called when the stream wants to pull more data in\n// The advisory `size` argument is ignored in this case and user specified use or default to 255kk.\nGridReadStream.prototype._read = function _read (size) {\n  var self = this;\n\n  // Set `_needToPush` to true because the store may still be closed if data is immediately piped. Once the store is open `_needToPush` is checked and _push() called if necessary.\n  self._needToPush = true;\n\n  // The store must be open\n  if (!this._opened) return;\n\n  // Read data from GridStore and push to stream\n  self._push();\n}\n\n/**\n * _push\n *\n * @api private\n */\n\nGridReadStream.prototype._push = function _push () {\n  var self = this;\n\n  // Do not continue if the store is closed\n  if (!this._opened) return self._error('Unable to push data. Expected gridstore to be open');\n\n  // Check if EOF, if the full requested range has been pushed or if the stream must be destroyed. If so than push EOF-signalling `null` chunk\n  if ( !this._store.eof() && (self._currentPos <= self.range.endPos) && !this._end) {\n\n    // Determine the chunk size for the read from GridStore\n    // Use default chunk size or user specified\n    var readChunkSize = self._chunkSize\n    // Override the chunk size if the chunk size is more than the size that is left until EOF/range\n    if (self.range.endPos-self._currentPos < self._chunkSize) {readChunkSize = self.range.endPos - self._currentPos + 1};\n\n    // Read the chunk from GridSore. Head moves automatically after each read.\n    self._store.read(readChunkSize,function(err, data) {\n\n      // If error stop and close the store\n      if (err) return self._error(err);\n\n      // Advance the current position of the read head\n      self._currentPos += data.length;\n\n      // Push data\n      if (!self._end) self.push(data)\n    })\n\n\n  } else {\n    // Push EOF-signalling `null` chunk\n    this._end = true;\n    self.push(null);\n  }\n}\n\n/**\n * _close\n *\n * @api private\n */\n\nGridReadStream.prototype._close = function _close () {\n  var self = this;\n  if (!self._opened) return;\n  if (self._closing) return;\n  this._closing = true;\n\n  // Close the store and emit `close` event\n  self._store.close(function (err) {\n    if (err) return self._error(err);\n    self.emit('close');\n  });\n}\n\n/**\n * _error\n *\n * @api private\n */\n\nGridReadStream.prototype._error = function _error (err) {\n  // Set end true so that no further reads from GridSotre are possible and close the store\n  this._end = true;\n\n  // Emit the error event\n  this.emit('error', err);\n\n  // Close the gridsore if an error is received.\n  this._close()\n}\n\n/**\n * destroy\n *\n * @api public\n */\n\nGridReadStream.prototype.destroy = function destroy () {\n  // Set end true so that no further reads from GridSotre are possible and close the store\n  this._end = true;\n  this._close();\n}\n"]},"metadata":{},"sourceType":"module"}