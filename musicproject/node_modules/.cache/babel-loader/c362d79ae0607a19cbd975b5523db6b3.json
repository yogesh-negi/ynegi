{"ast":null,"code":"/*\n * Copyright (c) 2013 ObjectLabs Corporation\n * Distributed under the MIT license - http://opensource.org/licenses/MIT\n */\n\n/**\n * Creates a parser.\n *\n * @param {Object=} options\n * @constructor\n */\nfunction MongodbUriParser(options) {\n  if (options && options.scheme) {\n    this.scheme = options.scheme;\n  }\n}\n/**\n * Takes a URI of the form:\n *\n *   mongodb://[username[:password]@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database]][?options]\n *\n * and returns an object of the form:\n *\n *   {\n *     scheme: !String,\n *     username: String=,\n *     password: String=,\n *     hosts: [ { host: !String, port: Number= }, ... ],\n *     database: String=,\n *     options: Object=\n *   }\n *\n * scheme and hosts will always be present. Other fields will only be present in the result if they were\n * present in the input.\n *\n * @param {!String} uri\n * @return {Object}\n */\n\n\n_c = MongodbUriParser;\n\nMongodbUriParser.prototype.parse = function parse(uri) {\n  var uriObject = {};\n  var i = uri.indexOf('://');\n\n  if (i < 0) {\n    throw new Error('No scheme found in URI ' + uri);\n  }\n\n  uriObject.scheme = uri.substring(0, i);\n\n  if (this.scheme && this.scheme !== uriObject.scheme) {\n    throw new Error('URI must begin with ' + this.scheme + '://');\n  }\n\n  var rest = uri.substring(i + 3);\n  i = rest.indexOf('@');\n\n  if (i >= 0) {\n    var credentials = rest.substring(0, i);\n    rest = rest.substring(i + 1);\n    i = credentials.indexOf(':');\n\n    if (i >= 0) {\n      uriObject.username = decodeURIComponent(credentials.substring(0, i));\n      uriObject.password = decodeURIComponent(credentials.substring(i + 1));\n    } else {\n      uriObject.username = decodeURIComponent(credentials);\n    }\n  }\n\n  i = rest.indexOf('?');\n\n  if (i >= 0) {\n    var options = rest.substring(i + 1);\n    rest = rest.substring(0, i);\n    uriObject.options = {};\n    options.split('&').forEach(function (o) {\n      var iEquals = o.indexOf('=');\n      uriObject.options[decodeURIComponent(o.substring(0, iEquals))] = decodeURIComponent(o.substring(iEquals + 1));\n    });\n  }\n\n  i = rest.indexOf('/');\n\n  if (i >= 0) {\n    // Make sure the database name isn't the empty string\n    if (i < rest.length - 1) {\n      uriObject.database = decodeURIComponent(rest.substring(i + 1));\n    }\n\n    rest = rest.substring(0, i);\n  }\n\n  this._parseAddress(rest, uriObject);\n\n  return uriObject;\n};\n/**\n * Parses the address into the uriObject, mutating it.\n *\n * @param {!String} address\n * @param {!Object} uriObject\n * @private\n */\n\n\nMongodbUriParser.prototype._parseAddress = function _parseAddress(address, uriObject) {\n  uriObject.hosts = [];\n  address.split(',').forEach(function (h) {\n    var i = h.indexOf(':');\n\n    if (i >= 0) {\n      uriObject.hosts.push({\n        host: decodeURIComponent(h.substring(0, i)),\n        port: parseInt(h.substring(i + 1))\n      });\n    } else {\n      uriObject.hosts.push({\n        host: decodeURIComponent(h)\n      });\n    }\n  });\n};\n/**\n * Takes a URI object and returns a URI string of the form:\n *\n *   mongodb://[username[:password]@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database]][?options]\n *\n * @param {Object=} uriObject\n * @return {String}\n */\n\n\nMongodbUriParser.prototype.format = function format(uriObject) {\n  if (!uriObject) {\n    return (this.scheme || 'mongodb') + '://localhost';\n  }\n\n  if (this.scheme && uriObject.scheme && this.scheme !== uriObject.scheme) {\n    throw new Error('Scheme not supported: ' + uriObject.scheme);\n  }\n\n  var uri = (this.scheme || uriObject.scheme || 'mongodb') + '://';\n\n  if (uriObject.username) {\n    uri += encodeURIComponent(uriObject.username); // While it's not to the official spec, we allow empty passwords\n\n    if (uriObject.password) {\n      uri += ':' + encodeURIComponent(uriObject.password);\n    }\n\n    uri += '@';\n  }\n\n  uri += this._formatAddress(uriObject); // While it's not to the official spec, we only put a slash if there's a database, independent of whether there are options\n\n  if (uriObject.database) {\n    uri += '/' + encodeURIComponent(uriObject.database);\n  }\n\n  if (uriObject.options) {\n    Object.keys(uriObject.options).forEach(function (k, i) {\n      uri += i === 0 ? '?' : '&';\n      uri += encodeURIComponent(k) + '=' + encodeURIComponent(uriObject.options[k]);\n    });\n  }\n\n  return uri;\n};\n/**\n * Formats the address portion of the uriObject, returning it.\n *\n * @param {!Object} uriObject\n * @return {String}\n * @private\n */\n\n\nMongodbUriParser.prototype._formatAddress = function _formatAddress(uriObject) {\n  var address = '';\n  uriObject.hosts.forEach(function (h, i) {\n    if (i > 0) {\n      address += ',';\n    }\n\n    address += encodeURIComponent(h.host);\n\n    if (h.port) {\n      address += ':' + encodeURIComponent(h.port);\n    }\n  });\n  return address;\n};\n/**\n * Takes either a URI object or string and returns a Mongoose connection string. Specifically, instead of listing all\n * hosts and ports in a single URI, a Mongoose connection string contains a list of URIs each with a single host and\n * port pair.\n *\n * Useful in environments where a MongoDB URI environment variable is provided, but needs to be programmatically\n * transformed into a string digestible by mongoose.connect()--for example, when deploying to a PaaS like Heroku\n * using a MongoDB add-on like MongoLab.\n *\n * @param {!Object|String} uri\n * @return {String}\n */\n\n\nMongodbUriParser.prototype.formatMongoose = function formatMongoose(uri) {\n  var parser = this;\n\n  if (typeof uri === 'string') {\n    uri = parser.parse(uri);\n  }\n\n  if (!uri) {\n    return parser.format(uri);\n  }\n\n  var connectionString = '';\n  uri.hosts.forEach(function (h, i) {\n    if (i > 0) {\n      connectionString += ',';\n    } // This trick is okay because format() never dynamically inspects the keys in its argument\n\n\n    var singleUriObject = Object.create(uri);\n    singleUriObject.hosts = [h];\n    connectionString += parser.format(singleUriObject);\n  });\n  return connectionString;\n};\n\nexports.MongodbUriParser = MongodbUriParser;\nvar defaultParser = new MongodbUriParser();\n['parse', 'format', 'formatMongoose'].forEach(function (f) {\n  exports[f] = defaultParser[f].bind(defaultParser);\n});\n\nvar _c;\n\n$RefreshReg$(_c, \"MongodbUriParser\");","map":{"version":3,"sources":["C:/Users/Yogesh/Desktop/musicplayer/musicapp/musicproject/src/api/node_modules/mongodb-uri/mongodb-uri.js"],"names":["MongodbUriParser","options","scheme","prototype","parse","uri","uriObject","i","indexOf","Error","substring","rest","credentials","username","decodeURIComponent","password","split","forEach","o","iEquals","length","database","_parseAddress","address","hosts","h","push","host","port","parseInt","format","encodeURIComponent","_formatAddress","Object","keys","k","formatMongoose","parser","connectionString","singleUriObject","create","exports","defaultParser","f","bind"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2013 ObjectLabs Corporation\n * Distributed under the MIT license - http://opensource.org/licenses/MIT\n */\n\n/**\n * Creates a parser.\n *\n * @param {Object=} options\n * @constructor\n */\nfunction MongodbUriParser(options) {\n    if (options && options.scheme) {\n        this.scheme = options.scheme;\n    }\n}\n\n/**\n * Takes a URI of the form:\n *\n *   mongodb://[username[:password]@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database]][?options]\n *\n * and returns an object of the form:\n *\n *   {\n *     scheme: !String,\n *     username: String=,\n *     password: String=,\n *     hosts: [ { host: !String, port: Number= }, ... ],\n *     database: String=,\n *     options: Object=\n *   }\n *\n * scheme and hosts will always be present. Other fields will only be present in the result if they were\n * present in the input.\n *\n * @param {!String} uri\n * @return {Object}\n */\nMongodbUriParser.prototype.parse = function parse(uri) {\n\n    var uriObject = {};\n\n    var i = uri.indexOf('://');\n    if (i < 0) {\n        throw new Error('No scheme found in URI ' + uri);\n    }\n    uriObject.scheme = uri.substring(0, i);\n    if (this.scheme && this.scheme !== uriObject.scheme) {\n        throw new Error('URI must begin with ' + this.scheme + '://');\n    }\n    var rest = uri.substring(i + 3);\n\n    i = rest.indexOf('@');\n    if (i >= 0) {\n        var credentials = rest.substring(0, i);\n        rest = rest.substring(i + 1);\n        i = credentials.indexOf(':');\n        if (i >= 0) {\n            uriObject.username = decodeURIComponent(credentials.substring(0, i));\n            uriObject.password = decodeURIComponent(credentials.substring(i + 1));\n        } else {\n            uriObject.username = decodeURIComponent(credentials);\n        }\n    }\n\n    i = rest.indexOf('?');\n    if (i >= 0) {\n        var options = rest.substring(i + 1);\n        rest = rest.substring(0, i);\n        uriObject.options = {};\n        options.split('&').forEach(function (o) {\n            var iEquals = o.indexOf('=');\n            uriObject.options[decodeURIComponent(o.substring(0, iEquals))] = decodeURIComponent(o.substring(iEquals + 1));\n        });\n    }\n\n    i = rest.indexOf('/');\n    if (i >= 0) {\n        // Make sure the database name isn't the empty string\n        if (i < rest.length - 1) {\n            uriObject.database = decodeURIComponent(rest.substring(i + 1));\n        }\n        rest = rest.substring(0, i);\n    }\n\n    this._parseAddress(rest, uriObject);\n\n    return uriObject;\n\n};\n\n/**\n * Parses the address into the uriObject, mutating it.\n *\n * @param {!String} address\n * @param {!Object} uriObject\n * @private\n */\nMongodbUriParser.prototype._parseAddress = function _parseAddress(address, uriObject) {\n    uriObject.hosts = [];\n    address.split(',').forEach(function (h) {\n        var i = h.indexOf(':');\n        if (i >= 0) {\n            uriObject.hosts.push(\n                    {\n                        host: decodeURIComponent(h.substring(0, i)),\n                        port: parseInt(h.substring(i + 1))\n                    }\n            );\n        } else {\n            uriObject.hosts.push({ host: decodeURIComponent(h) });\n        }\n    });\n};\n\n/**\n * Takes a URI object and returns a URI string of the form:\n *\n *   mongodb://[username[:password]@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database]][?options]\n *\n * @param {Object=} uriObject\n * @return {String}\n */\nMongodbUriParser.prototype.format = function format(uriObject) {\n\n    if (!uriObject) {\n        return (this.scheme || 'mongodb') + '://localhost';\n    }\n\n    if (this.scheme && uriObject.scheme && this.scheme !== uriObject.scheme) {\n        throw new Error('Scheme not supported: ' + uriObject.scheme);\n    }\n    var uri = (this.scheme || uriObject.scheme || 'mongodb') + '://';\n\n    if (uriObject.username) {\n        uri += encodeURIComponent(uriObject.username);\n        // While it's not to the official spec, we allow empty passwords\n        if (uriObject.password) {\n            uri += ':' + encodeURIComponent(uriObject.password);\n        }\n        uri += '@';\n    }\n\n    uri += this._formatAddress(uriObject);\n\n    // While it's not to the official spec, we only put a slash if there's a database, independent of whether there are options\n    if (uriObject.database) {\n        uri += '/' + encodeURIComponent(uriObject.database);\n    }\n\n    if (uriObject.options) {\n        Object.keys(uriObject.options).forEach(function (k, i) {\n            uri += i === 0 ? '?' : '&';\n            uri += encodeURIComponent(k) + '=' + encodeURIComponent(uriObject.options[k]);\n        });\n    }\n\n    return uri;\n\n};\n\n/**\n * Formats the address portion of the uriObject, returning it.\n *\n * @param {!Object} uriObject\n * @return {String}\n * @private\n */\nMongodbUriParser.prototype._formatAddress = function _formatAddress(uriObject) {\n    var address = '';\n    uriObject.hosts.forEach(function (h, i) {\n        if (i > 0) {\n            address += ',';\n        }\n        address += encodeURIComponent(h.host);\n        if (h.port) {\n            address += ':' + encodeURIComponent(h.port);\n        }\n    });\n    return address;\n};\n\n/**\n * Takes either a URI object or string and returns a Mongoose connection string. Specifically, instead of listing all\n * hosts and ports in a single URI, a Mongoose connection string contains a list of URIs each with a single host and\n * port pair.\n *\n * Useful in environments where a MongoDB URI environment variable is provided, but needs to be programmatically\n * transformed into a string digestible by mongoose.connect()--for example, when deploying to a PaaS like Heroku\n * using a MongoDB add-on like MongoLab.\n *\n * @param {!Object|String} uri\n * @return {String}\n */\nMongodbUriParser.prototype.formatMongoose = function formatMongoose(uri) {\n    var parser = this;\n    if (typeof uri === 'string') {\n        uri = parser.parse(uri);\n    }\n    if (!uri) {\n        return parser.format(uri);\n    }\n    var connectionString = '';\n    uri.hosts.forEach(function (h, i) {\n        if (i > 0) {\n            connectionString += ',';\n        }\n        // This trick is okay because format() never dynamically inspects the keys in its argument\n        var singleUriObject = Object.create(uri);\n        singleUriObject.hosts = [ h ];\n        connectionString += parser.format(singleUriObject);\n    });\n    return connectionString;\n};\n\nexports.MongodbUriParser = MongodbUriParser;\n\nvar defaultParser = new MongodbUriParser();\n[ 'parse', 'format', 'formatMongoose' ].forEach(function (f) {\n    exports[f] = defaultParser[f].bind(defaultParser);\n});\n"]},"metadata":{},"sourceType":"module"}